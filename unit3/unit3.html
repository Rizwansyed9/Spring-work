<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {height: 100%;
    margin: 0;
    
padding:5px;}
h3{
 
color:#212121;
}
h4{
color:#1b1b1b;
}
p,li{
  font-size: 16px;
color:#757575;
}
.card {
background-color:#ffffff;
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    transition: 0.3s;

}

.card:hover {
    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
}

.container {

    padding: 1px 8px;
}
code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	 font-size: 12px;
  line-height: 1.375;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;


	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #f8f8f2;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

pre.line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre.line-numbers > code {
	position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}
.tip {
    background-image: url(https://www.w3schools.in/wp-content/uploads/tip.png);
    padding: 10px 10px 10px 50px;
    background-position: 10px 20px;
    background-repeat: no-repeat;
	display: table;
    border: 2px solid #DDD;
    border-left: 3px solid #32cd32;
    margin-left: 0;


    border-radius: 3px;
}
.tip2{
  padding: 10px 10px 10px 10px;
    background-position: 10px 20px;
    background-repeat: no-repeat;
	display: table;
    border: 2px solid #DDD;
    border-left: 3px solid #32cd32;
    margin-left: 0;


    border-radius: 3px;

}

img {
    max-width: 100%;
    max-height: 100vh;
    height: auto;
}

table {
    font-family: arial, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
}

tr:nth-child(even) {
    background-color: #dddddd;
}

</style>
</head>
<body>


<div class="card">
 
  <div class="container">
<h3>Spring Core (Advanced)</h3>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Using P & C - Namespace</span></div>
<p>If we want to perform setter injection on a spring bean we need to use &ltproperty&gt tag.  Instead of writing length &ltproperty&gt tag declaration under the &ltbean&gt tag, we can replace with short form of representing the same with p-namespace.<br><br> 
In order to use the p-namespace, you first need to import the "http://www.springframework.org/schema/p" namespace in the spring bean configuration file. Once you have imported it, you have to write the attribute at the<bean> tag level to perform the injection as p:propertyname="value" or p:propertyname-ref="refbean".<br><br>  
C-Namespace has been introduced in spring 3.1.1, in order to perform constructor injection we need to use &ltconstructor-arg&gt tag. Instead of writing the length &ltconstructor-arg&gt tag, we can replace it with c-namespace. The syntax for writing the C-Namespace is c:argument="value" or c:-argument-ref="refbean"</p>
<p  style="font-weight:bold;color:#212121">Course.java</p>
  <pre ><code class="language-java">package com.pnamespace.beans; 
public class Course {  
private int id;  
private String name; 
public int getId() {   
return id;  
} 
public void setId(int id) {   
this.id = id;  
} 
public String getName() {   
return name;  
} 
public void setName(String name) {   
this.name = name;  
} 
} </code></pre>	
<p  style="font-weight:bold;color:#212121">Person.java </p>
  <pre ><code class="language-java">package com.pnamespace.beans; 
public class Person {  
private Course course; 
public Person(Course course) {   
this.course = course;  
}    
public void whichCourse() {   
System.out.println("Course : " + course.getName());  
} 
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml </p>
  <pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
&ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns:c="http://www.springframework.org/schema/c"  
xmlns:p="http://www.springframework.org/schema/p"  
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">  
&ltbean id="course" class="com.pnamespace.beans.Course" p:id="34" p:name="Java"/>  
&ltbean id="person" class="com.pnamespace.beans.Person" c:courseref="course"/> 
&lt/beans> </code></pre>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Dependency Check</span></div>
<p>In case of constructor injection, all the dependent objects are mandatory to be passed via &ltconstructor-arg&gt tag while declaring the bean, but in case of setter injection the dependent objects are not mandatory to be injected. So, if want setter properties mandatory like similar to constructor properties then we need to use Dependency Check.<br><br> 
Dependency check has been removed from Spring 2.5. From spring 2.5 it has been replaced with @Required annotation, we will discuss about it in spring annotations support.<br><br> 
In order to perform the mandatory check on setter properties you need to enable dependency check. In order to enable dependency check you have to write the attribute dependency-check="mode". Dependency check can be enabled in three modes. </p>
<ol>
<li>Simple - when you turn the dependency check in simple mode, it will check all the primitive attributes of your bean (attributes contains setters) whether those has been configured with values in configuration file. If any primitive attribute is not configured with &ltproperty&gt or p-namespace in configuration automatically the core container will detects and throws error without creating the container.</li>
<li> Object- when you turn on the dependency check in object mode, it will check all the Object type attributes on your target class whether those has been configured the property injection in configuration, if not will throw exception as said above</li>
<li>all - when you turn on the dependency check as all mode, it will check for both simple and objects types of your class attributes, if those values are not injected through configuration it will throw exception</li>
</ol>
<p>Refer the example for the same.</p> 
<p  style="font-weight:bold;color:#212121">Engine.java </p>
  <pre ><code class="language-java">package com.dc.beans; 
public class Engine {  
private int id;  
private String name; 
public int getId() {   
return id;  
} 
public void setId(int id) {   
this.id = id;  
} 
public String getName() {   
return name;  
} 
public void setName(String name) {   
this.name = name;  
} 
}</code></pre> 
<p  style="font-weight:bold;color:#212121">Motor.java</p>
  <pre ><code class="language-java">package com.dc.beans; 
public class Motor {  
private Engine engine; 
public void setEngine(Engine engine) {   
this.engine = engine;  
} 
public void run() {   
System.out.println("Running with engine : " + engine.getName());  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
  <pre ><code class="language-java">&ltbean id="engine" class="com.dc.beans.Engine" dependency-check="simple">  
&ltproperty name="id" value="24"/>  
&ltproperty name="name" value="100 cc"/> 
&lt/bean> 
&ltbean id="motor" class="com.dc.beans.Motor" dependency-check="objects">  
&ltproperty name="engine" ref="engine"/> 
&lt/bean>  </code></pre>
<p>The main drawback with dependency check is you don't have control on which attribute should be made as mandatory and which is optional, either you can the dependency check at simple level or object or all.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Depends-On</span></div>
<p>If a class uses the functionality of other class inside it, then those classes are directly dependent on each other. But every class may not directly dependent on other; sometimes there may be indirect dependency. Let us consider a use case to understand.<br><br> 
We have a class LoanCalculator, it has a method calInst to it we pass principle, noofmonths and city name as input. When we call this method it should find the applicable rate of interest for the city we passed by fetching it from properties file. </p>
  <pre ><code class="language-java">package com.don.beans; 
import java.util.Properties; 
public class LoanCalculator {  
public double calInst(Long principle, int n, String city) throws Exception {   
float ri = 0.0f;   
double amt = 0.0f;   
Properties cityInsProps = null;      
// read the data from properties file   
// load into properties collection   
// now find the rate of interest for the given city 
amt = (principle * n * ri) / 100;   return amt;  
} 
} </code></pre>
<p>The problem with above code is we will read the same data repeatedly for every call to the calIns method of the LoanCalculator class.<br><br> 
So instead we want to cache the data so that the LoanCalculator now can go and get the data from cache. So for this when we call calIns method we will check whether the data is available with cache or not. If it is not available we will read the city and rate of Interest values from properties file as key and values and place in properties collection.<br><br> 
Now we will store this properties collection into the Cache as shown below. As now the data is available in cache we can pull the data from Cache itself.</p>
  <pre ><code class="language-java">package com.don.beans; 
public class LoanCalculator {  
public double calInst(Long principle, int n, String city) throws Exception {   
float ri = 0.0f;   
double amt = 0.0f;   
Cache cache = null;   
Properties cityInsProps = null; 
cache = Cache.getInstance();   
if (cache.containsKey("cityRI") == false) {    
// read the data from properties file    
// make it as properties collection    
// store in the cache with key as "cityRI"   
}    
cityInsProps = cache.get("cityRI");   
ri = Float.parseFloat(cityInsProps.getProperty(city));   
amt = (principle * n * ri) / 100;   
return amt;  
} 
}  </code></pre>
<p>
 
 
Is there any problem in the above piece of logic, yes the problem is here the city and rate of interest values may not only required for LoanCalculator there may be several other classes in the application want to read the data from Cache. So, we need to write the logic for checking the data is available in the cache if not load the data into cache and use it.<br><br> 
So, we end up in duplicating the same logic across various places in the application. Instead can we write the logic for populating the data into cache in cache constructor? Yes it seems a good idea because constructor of the cache will be called only once as it is singleton and we need to read the data only once, the better place to write the logic for populating is in constructor of the class as shown below.</p>
  <pre ><code class="language-java">package com.don.beans; 
public class LoanCalculator {  
public double calInst(Long principle, int n, String city) throws Exception {   
float ri = 0.0f;   
double amt = 0.0f;   
Cache cache = null;   
Properties cityInsProps = null;   
cache = Cache.getInstance();   
cityInsProps = (Properties) cache.get("cityRI");   
if (cityInsProps == null) {    
throw new Exception("Internal error");   
}   
if (cityInsProps.containsKey(city) == false) {    
throw new Exception("City not valid");   
}   
ri = Float.parseFloat(cityInsProps.getProperty(city));   
amt = (principle * n * ri) / 100;   
return amt;  
} 
} </code></pre>
  <pre ><code class="language-java">package com.don.util; 
public class Cache {  
private Map&ltString, Object&gt dataMap; 
public Cache() {   
dataMap = new HashMap&ltString, Object>();   
// write the logic for reading the data from properties file   
// put that into properties collection   
// and store it into dataMap  
}  
public void put(String key, Object val) {   
dataMap.put(key, val);  
}  
public Object get(String key) {   
return dataMap.get(key);  
}  
public boolean containsKey(String key) {   
return dataMap.containsKey(key);  
} 
}  </code></pre>
<p>Is there any problem with the above code, yes? Here the cache is exposed to the details of the source from where the data is coming from. Due to which any changes to the underlying source again will affect the cache.<br><br> 
Instead we should never write the logic for populating the data into cache rather we should write that logic in separate class called CacheManager. CacheManager is the one responsible for reading the data from underlying source system and massaging the data and storing the data into Cache.</p>
  <pre ><code class="language-java">package com.don.util; 
public class CacheManager {  
public CacheManager() {      
init();  
}  
public void init() {   
Cache cache = null;      
cache = Cache.getInstance();   
// read the data and populate into cache  
} 
} </code></pre>
<p>Again is there any problem with above code? Yes, as the data comes from several source systems again we will write multiple access related logic in one single class. This may become complicated and difficult to manage and modify</p>
<p>Instead write the logic for reading the data from source system in Accessor class. Now CacheManager will talk to Accessors in retrieving the data and populating into cache.<br><br> 
Now if we observe LoanCalculator is dependent on Cache or CacheManager to read the data. LoanCalculator never talks to CacheManager rather it reads the data from Cache. But inorder to populate the data into Cache, the CacheManager should be created first than LoanCalculator.<br><br> 
So here the LoanCalculator and CacheManager are indirectly dependent on each other. Before the LoanCalculator gets created, always the CacheManager has to be created first. This is called creational dependencies these can be managed using depends on as shown below. </p>
  <pre ><code class="language-java">package com.don.util; 
import java.util.Map; 
import com.don.accessor.IAccessor; 
public class CacheManager {  
private Cache cache;  
private Map&ltString, IAccessor> accessorMap; 
public CacheManager(Cache cache, Map&ltString, IAccessor> accessorMap) {   
this.cache = cache;   
this.accessorMap = accessorMap;   
init();  
} 
public void init() {   
Object data = null;   
IAccessor accessor = null;      
for (String dataKey : accessorMap.keySet()) {    
accessor = accessorMap.get(dataKey);    
data = accessor.getData();    
cache.put(dataKey, data);   
}  
} 
} </code></pre>
  <pre ><code class="language-java">package com.don.util; 
import java.util.HashMap; 
import java.util.Map; 
public class Cache {  
private Map&ltString, Object> dataMap; 
public Cache() {   
dataMap = new HashMap&ltString, Object>();  
} 
public void put(String key, Object val) {   
dataMap.put(key, val);  } 
public Object get(String key) {   
return dataMap.get(key);  } 
public boolean containsKey(String key) {   
return dataMap.containsKey(key);  } 
} </code></pre>
  <pre ><code class="language-java">package com.don.accessor; 
public interface IAccessor {  
Object getData(); 
} </code></pre>
  <pre ><code class="language-java">package com.don.accessor; 
import java.util.Properties; 
import java.util.ResourceBundle; 
public class CityInterestAccessor implements IAccessor {  
@Override  public Object getData() {   
ResourceBundle rb = null;   
Properties props = null; 
rb = ResourceBundle.getBundle("com/don/common/cityins");   
props = new Properties();   
for (String key : rb.keySet()) {    
props.put(key, rb.getString(key));   
}   
return props;  
} 
} </code></pre>
  <pre ><code class="language-java">package com.don.beans; 
import java.util.Properties; 
import com.don.util.Cache; 
public class LoanCalculator {  
private Cache cache;  
public double calInst(Long principle, int n, String city) throws Exception {   
float ri = 0.0f;   
double amt = 0.0f;   
Properties cityInsProps = null;   
cityInsProps = (Properties) cache.get("cityRI");   
if (cityInsProps == null) {    
throw new Exception("Internal error");   
}   
if (cityInsProps.containsKey(city) == false) {    
throw new Exception("City not valid");   
}   
ri = Float.parseFloat(cityInsProps.getProperty(city));   
amt = (principle * n * ri) / 100;   
return amt;  
}  
public void setCache(Cache cache) {   
this.cache = cache;  
} 
}  </code></pre>
  <pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
&ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
&ltbean id="loanCalculator" class="com.don.beans.LoanCalculator" dependson="cacheManager">   
&ltproperty name="cache" ref="cache" />  
&lt/bean>  
&ltbean id="cache" class="com.don.util.Cache" />  
&ltbean id="cacheManager" class="com.don.util.CacheManager">   
&ltconstructor-arg ref="cache" />   
&ltconstructor-arg>    
&ltmap key-type="java.lang.String" valuetype="com.don.accessor.IAccessor">     
&ltentry key="cityRI" value-ref="cityInsAccessor" />    
&lt/map>   &lt/constructor-arg>  
&lt/bean>  
&ltbean id="cityInsAccessor" class="com.don.accessor.CityInterestAccessor" /> 
&lt/beans> </code></pre>  
 <p  style="font-weight:bold;color:#212121">cityins.properties </p>
  <pre ><code class="language-java">hyd=12.12 
chn=11.12 
blr=10.23 </code></pre> 
  
  <pre ><code class="language-java">package com.don.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.don.beans.LoanCalculator; 
public class DONTest {  
public static void main(String[] args) throws Exception {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/don/common/application-context.xml"));   
LoanCalculator lc = factory.getBean("loanCalculator",     LoanCalculator.class);   
double amt = lc.calInst(100L, 12, "hyd");   
System.out.println("Interest amount : " + amt);  
} 
} </code></pre>
<p>In the above code for the bean id loanCalculator we added one attribute depends-on pointing to the cacheManager. This means before creating the loanCalculator always Spring IOC container should create cacheManager first.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Lifecycle</span></div>
<p>Bean lifecycle allows a way to provide spring beans to perform initialization or disposable operations.  
If you consider a Servlet, J2EE containers will call the init and destroy methods after creating the servlet object and before removing it from the web container respectively. In the Servlet init method, developer has to write the initialization logic to initialize the Servlet and destroy method he needs to write the code for releasing the resources to facilitate the destruction process.<br><br> 
If you consider a POJO in Java, initialization logic has to be written in the constructor and resource release logic should be written in the finalize method.<br><br> 
So, for a spring bean also can we use Constructor and finalize as the lifecycle methods. The answer here is "o". When we are performing initialization always we don't want  to initialize with default or hardcoded values sometimes we wanted to initialize the state of a bean with user supplied values. How to pass the values as input while creating the bean in spring. There are two ways one is constructor injection and other is setter injection. If we recall the setter injection values are not accessible within the constructor of the class as those gets injected after the class has been created. This indicates we cannot initialize the state of the bean in constructor as all the values are not available.<br><br> 
We need a separate initialization hookup that will be called after all the values are injected so, that we can write the initialization logic. That's where BeanLifecycle comes into picture.<br><br> 
In order to do this spring provides three ways to work with Bean Lifecycle</p>
<ol>
<li>Declarative approach </li>
<li>Programmatic approach</li>
<li>Annotation based approach</li>
</ol>
  <p  style="font-weight:bold;color:#212121">Declarative approach </p>
<p>In the declarative approach you will declare the init and destroy methods of a bean in spring beans configuration file. In the bean class declare the methods whose signature must be public and should have return type as void and should not take any parameters, any method which follows this signature can be used as lifecycle methods.<br><br> 
After writing the methods in your bean, you need to declare those methods as lifecycle methods in spring configuration file, at the &ltbean> tag level, you need to declare two attributes init-method = "methodname" and destroy-method = "destroymethod".<br><br>  
IOC container after creating the bean (this includes after all injections); it will automatically calls the init method to perform the initialization. But spring IOC container cannot automatically calls the destroy-method of the bean class, because in spring core application IOC container will not be able to judge when the bean is available for garbage collection or how many references of this bean is held by other beans.<br><br>  
In order to invoke the destroy-method on the bean class you need to explicitly call on the ConfigurableListableBeanFactory, destroySingleton or destroyScopedBean("beanscope") method, so that IOC container delegates the call to all the beans destroy-methods in that IOC container.<br><br> 
Refer to the below example on how to work with declarative approach.</p>
<p  style="font-weight:bold;color:#212121">Robot.java</p>
  <pre ><code class="language-java">package com.blc.beans; 
public class Robot {  
private String name;  
private SensorDriver driver; 
public Robot(SensorDriver driver) {   
this.driver = driver;  
} 
public void setName(String name) {   
this.name = name;  
}    
public void startup() {   
System.out.println("Driver Type : " + driver.getType());   
System.out.println("Name : " + name);  
}    
public void release() {   
System.out.println("releasing resources....");  
} 
} </code></pre>
  <p  style="font-weight:bold;color:#212121">SensorDriver.java </p>
  <pre ><code class="language-java">package com.blc.beans; 
public class SensorDriver {  
private String type; 
public String getType() {   
return type;  
} 
public void setType(String type) {   
this.type = type;  
} 
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
  <pre ><code class="language-java">&ltbean id="robot" class="com.blc.beans.Robot" init-method="startup" destroymethod="release">  
&ltconstructor-arg ref="driver"/>  
&ltproperty name="name" value="Robot 1"/> 
&lt/bean> 
&ltbean id="driver" class="com.blc.beans.SensorDriver">  
&ltproperty name="type" value="IR"/> 
&lt/bean>  </code></pre>
  <p  style="font-weight:bold;color:#212121">BLCTest.java</p>
  <pre ><code class="language-java">package com.blc.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.blc.beans.Robot; 
import com.blc.beans.ShutdownHookThread; 
public class BLCTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/blc/common/application-context.xml"));     
Robot robot = factory.getBean("robot", Robot.class);   
((ConfigurableListableBeanFactory)factory).destroySingletons();  
} 
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">Programmatic approach</p>
<p>The problem with declarative approach is developer has provide the init and destroy method declarations for each bean of that class in configuration, if he misses for atleast one bean, then the initialization or destruction will not happen. It would be tough to maintain the configuration, lets say if the init or destroy method name changed in class, all the references to those methods in the configuration has to be modified to match with class method names.<br><br> 
In order to avoid the problems with this spring has provided programmatic approach. In this the bean class has to implement from two interfaces InitializingBean interface to handle initialization process and DisposableBean interface to handle destruction process and should override afterPropertiesSet and destroy methods respectively.<br><br> 
Now the developer don't need to declare these methods as init-method or destroy-method rather the core container while creating these beans will detectthese beans as InitializingBean type or DisposableBean type and calls the afterPropertiesSet and destroy method automatically.<br><br> 
The Robot.java has been modified to depict the same.</p>  
<p  style="font-weight:bold;color:#212121">Modified# 1 - Robot.java</p>
  <pre ><code class="language-java">package com.blc.beans; 
import org.springframework.beans.factory.DisposableBean; 
import org.springframework.beans.factory.InitializingBean; 
public class Robot implements InitializingBean, DisposableBean {  private String name;  private SensorDriver driver; 
public Robot(SensorDriver driver) {   
this.driver = driver;  
} 
public void setName(String name) {   
this.name = name;  } 
@Override  public void destroy() throws Exception {   
System.out.println("From destroy()");   
System.out.println("destroying dependents....");  
} 
@Override  public void afterPropertiesSet() throws Exception {   
System.out.println("From afterPropertiesSet()");   
System.out.println("Driver Type : " + driver.getType());   
System.out.println("Name : " + name);  
} 
} </code></pre>
<p>We will discuss about the annotation approach while we are dealing with annotations</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Aware Interfaces</span></div>
<p>Many times a bean has to refer to the environment in which it is living. If you recall the discussion of Contextual Dependency lookup, you will understand.<br><br> 
Servlet wants to access the environment in which it is running. To access the environment it needs ServletContext, but to get the ServletContext it needs ServletConfig.<br><br> 
A Servlet cannot create a ServletConfig or it cannot get it by looking up in a registry because it is not an exposed object, rather it is internal object of the ServletContainer. To get the internal objects of the container, we need to implement or extend from container specific interface or class resply and should override the method. In this case we need to implement Servlet interface or extend from HttpServlet class and should override the init() method. ServletContainer calls this method at the appropriate phase during the creation of Servlet object and passes the ServletConfig object as parameter.<br><br> 
So, if we want to get the container internal objects we need to implement the container provider interface and should override then the container is going to provide those objects.<br><br> 
In case of our spring bean also if it wants to access the environment in which it is living, we need to implements the Spring IOC container provided interface and should override a method, so that IOC container will automatically calls this method which creating the bean and injects the dependent object.<br><br> 
Let's consider one example to understand it.<br><br> 
I have a class "Car" it has a method run() and to "run" the car we need to call the start() method on the Engine. How Car will talk to the Engine, either we can use Composition or Inheritance. As it is recommended to use Composition we declare it as attribute. But we should not create the Object of Engine so, as we are using spring we can inject Engine into the Car.<br><br> 
But I don't want to create and don't want to inject, how can I use engine inside the car. I should pull the Engine.<br><br> 
To pull the Engine in the Car we need the reference of the BeanFactory. How to get the reference of the BeanFactory inside the bean. BeanFactory is not an external object rather bean factory is an implicit object of IOC container. To get the container internal objects we need to implement container provided interfaces and should override the method, which will be called by container.<br><br> 
So, here our Car should implements an interface provided by spring, BeanFactoryAware and should override the method, so IOC container will call that method and injects the BeanFactory as shown below.</p>
  <pre ><code class="language-java">package com.ai.beans; 
 
public interface IEngine {  void start(); } </code></pre>
  <pre ><code class="language-java">package com.ai.beans; 
public class EngineImpl implements IEngine { 
@Override  public void start() {   
System.out.println("starting...");  
} 
} </code></pre>
  <pre ><code class="language-java">package com.ai.beans; 
import org.springframework.beans.BeansException; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.BeanFactoryAware; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
public class Car implements BeanFactoryAware {  
private IEngine engine;  
private String beanId;  
private BeanFactory factory; 
public Car(String beanId) {   
System.out.println("Car()");   
this.beanId = beanId;  } 
public void run() {   
engine = factory.getBean(beanId, IEngine.class);   
engine.start();   
System.out.println("running...");  
} 
@Override  public void setBeanFactory(BeanFactory factory) throws BeansException {   
System.out.println("setBeanFactory()");   
this.factory = factory;  
} 
} </code></pre>
  <pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
&ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
&ltbean id="car" class="com.ai.beans.Car">   
&ltconstructor-arg>    
&ltidref bean="engine" />   
&lt/constructor-arg>  
&lt/bean>  
&ltbean id="engine" class="com.ai.beans.EngineImpl" /> 
&lt/beans> </code></pre>
  <pre ><code class="language-java">package com.ai.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.ai.beans.Car; 
public class AITest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/ai/common/application-context.xml"));   
Car car = factory.getBean("car", Car.class);   
car.run();  
} 
} </code></pre>
<li>When will the IOC container performs the Aware injection?</li>
<p>When we request for the bean from the IOC container, first IOC container identifies the bean definition and then starts instantiating. After performing a series of checks. Then while creating the object for the bean it performs constructor injection, after that setter injection and then detects is the class is implementing any Aware interfaces, If yes it calls the corresponding method and performs the injection.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Static Factory Method</span></div>
<p>When you configure a class as spring bean, IOC container will instantiate the bean by calling the new operator on it. But in java not all the classes can be instantiated out of new operator. For example Singleton classes cannot be instantiated using new operator, rather you need to call the static factory method that has been exposed by the class to create object of that class.<br><br>
So, for the classes which cannot be created out of new operator, those which has to be created by calling the static method that has been exposed in the class itself, you need to use static factory injection technic.<br><br> 
In this, after configuring the class as a bean, at the &ltbean> tag level you need to declare an attribute factory-method = "factorymethod" which is responsible for creating the object of that class. For example an alarm class needs an Calendar as dependent object, but java.util.Calendar class object cannot instantiated using new operation we need to call the getInstance() static method that is exposed in that class to get object of that class. Following example depicts the same.</p>
<p  style="font-weight:bold;color:#212121">Alarm.java</p>
  <pre ><code class="language-java">package com.sf.beans; 
import java.util.Calendar; 
public class Alarm {  
private Calendar time; 
public void setTime(Calendar time) {   
this.time = time;  }  public void ring() {   
System.out.println("Rining at : " + time.getTime());  
} 
} </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
  <pre ><code class="language-java">&ltbean id="cal" class="java.util.Calendar" factory-method="getInstance" /> 
&ltbean id="alarm" class="com.sf.beans.Alarm">  
&ltproperty name="time" ref="cal" /> 
&lt/bean </code></pre>
  <pre ><code class="language-java">package com.sf.beans; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.ai.beans.Car; 
public class AITest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/sf/common/application-context.xml"));   
Alarm alarm = factory.getBean("alarm", Alarm.class);   alarm.ring();  
} 
} </code></pre>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Instance Factory Method</span></div>
<p>As said above not all class objects cannot be created out of new operator, few can be constructed by calling factory method on the class, but few objects can be constructed by calling methods on other classes.<br><br> 
If you consider EJB's are any other distributed objects, those cannot be constructor out of new operator or a static method. In order to create an EJB object you need to look up the reference of home object in the JNDI and then you need to call the create() method on it to get the EJB Remote object. This indicates that creation of object involves some sequence of steps or operations to be performed, so these steps are coded in a separate class methods and generally those classes are called ServiceLocator's, these are the classes who knows how to instantiate the objects of other classes.<br><br> 
So, in order to create such type of objects you need to instantiate the ServiceLocator or helper class on which in-turn you need to call the factory method to create our class object. Instance Factory method injection allows you to instantiate classes object by calling method on other (ServiceLocator) class. For this you need to declare the (Service Locator) class on which you call the factory method as spring bean, along with this configure the (Target) bean which has to be created by the Service Locator and declare on the &ltbean&gt tag factory-bean is your service locator bean and factorymethod is your method in service locator class which will creates your target bean, which is shown below.</p>
<p  style="font-weight:bold;color:#212121">GoogleMapRenderer.java</p>
  <pre ><code class="language-java">package com.inf.beans; 
public class GoogleMapRenderer {  
private MapEngine mapEngine; 
public void render(String source, String destination) {   
String directions[] = mapEngine.getDirections(source, destination);   
System.out.println("Directions :");   
for (String d : directions) {    
System.out.println(d);   
}  
} 
public void setMapEngine(MapEngine mapEngine) {   
this.mapEngine = mapEngine;  
} 
} </code></pre>
  <p  style="font-weight:bold;color:#212121">MapEngine.java</p>
  <pre ><code class="language-java">package com.inf.beans; 
public interface MapEngine {  
String[] getDirections(String source, String destination); 
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">IndiaMapEngine.java</p>
  <pre ><code class="language-java">package com.inf.beans; 
public class IndiaMapEngine implements MapEngine { 
@Override  public String[] getDirections(String source, String destination) {   
return new String[] { "a", "b", "c" };  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">USMapEngine.java</p>
  <pre ><code class="language-java">package com.inf.beans; 
public class USMapEngine implements MapEngine { 
@Override  public String[] getDirections(String source, String destination) {   
return new String[] { "x", "y", "z" };  
} 
}  </code></pre>	
<p  style="font-weight:bold;color:#212121">MapEngineLocator.java </p>
  <pre ><code class="language-java">package com.inf.beans; 
public class MapEngineLocator {    
public MapEngine getIndiaMapEngine() {    
return new IndiaMapEngine();   
}    
public MapEngine getUSMapEngine() {    
return new USMapEngine();   
}  
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xm</p>
  <pre ><code class="language-java">&ltbean id="mapEngineLocator" class="com.inf.beans.MapEngineLocator" /> 
&ltbean id="indiaMapEngine" factory-bean="mapEngineLocator"  factory-method="getMapEngine" /> 
&ltbean id="usMapEngine" factory-bean="mapEngineLocator"  factory-method="getMapEngine"/>   
&ltbean id="googleMapRenderer" class="com.inf.beans.GoogleMapRenderer">  
&ltproperty name="mapEngine" ref="indiaMapEngine" /> 
&lt/bean> </code></pre>
  <pre ><code class="language-java">package com.inf.beans; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
public class AITest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/inf/common/application-context.xml"));   
GoogleMapRenderer gmr = factory.getBean("googleMapRenderer", GoogleMapRenderer.class);   
gmr.render("ameerpet", "kukatpally");  
} 
} </code></pre>
 <p>Problem with Static Factory method and Instance Factory method instantiation<br><br> 
 
The problem with static factory method and instance factory method injection is the factory method you configure should take zero arguments. In case if the factory method of your class takes parameters, it cannot be declared as factory-method in the configuration file.<br><br> 
The above statement indicates if your factory methods are not taking parameters means you cannot instantiate the object of your class with user supplied inputs, always the objects will be created with default values, it can be consider as a biggest limitation.</p> 
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Factory Bean</span></div>
<p>Factory classes are meant for creating the Object of other classes, here the name refers "Factory Bean" itself says these are the classes meant for creating the Bean's.<br><br> 
If we cannot create a class using "new" operator, we will write the code for creating the object of such classes within factory beans, this class will makes those objects as beans in the IOC container.<br><br> 
In order to work with Factory Beans, you need to create a class it should implement from FactoryBean interface and need to override three methods getObject, getObjectType and isSingleton. In the getObject method you need to create the object of the class you want to make as bean and return the Object.<br><br>  
In the getObjectType you need to return the class type of the Object and isSingleton indicates the object you want to create through the Factory is singleton or prototype.<br><br> 
As per the above we need "to write the logic for creating the Calendar class object in getObject(), need to return the type Calendar.class in getObjectType() and if you want the Calendar to place in the IOC container as a singleton bean then you should return "true" in isSingleton method as shown below.</p>
  <pre ><code class="language-java">package com.fb.beans; import java.util.Calendar; 
public class Alarm {  
private Calendar time;  
public void sayTime() {   
System.out.println(time.getTime());  
}  
public void setTime(Calendar time) {   
this.time = time;  
} 
} </code></pre>
  <pre ><code class="language-java">package com.fb.beans; 
import java.util.Calendar; 
import org.springframework.beans.factory.FactoryBean; 
public class CalendarFactoryBean implements FactoryBean&ltCalendar&gt {  
private int day;  
private int month;  
private int year; 
public CalendarFactoryBean(int day, int month, int year) {   
this.day = day;   
this.month = month;   
this.year = year;  
} 
@Override  public Calendar getObject() throws Exception {   
Calendar calendar = null;   System.out.println("getObject()");   
calendar = Calendar.getInstance();   
calendar.set(year, month, day);   
return calendar;  } 
@Override  public Class&lt?> getObjectType() {   
System.out.println("getObjectType()");   
return Calendar.class;  
} 
@Override  public boolean isSingleton() {   
System.out.println("isSingleton()");   
return true;  
} 
} </code></pre>
  <pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
&ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">  
&ltbean id="alarm" class="com.fb.beans.Alarm">   
&ltproperty name="time" ref="calendar" />  &lt/bean>  
&ltbean id="calendar" class="com.fb.beans.CalendarFactoryBean">   
&ltconstructor-arg value="10"/>   &ltconstructor-arg value="1"/>   
&ltconstructor-arg value="2014"/>  
&lt/bean> 
&lt/beans> </code></pre>
  <pre ><code class="language-java">package com.fb.test; 
import java.util.Calendar; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
public class FBTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/fb/common/application-context.xml"));   
Alarm alarm = factory.getBean("alarm", Alarm.class);   
alarm.sayTime();    
} 
} </code></pre>
<p>In the above configuration if you observe into the "time" property we are injection "calendar" reference. Here "time" is Calendar type attribute and "calendar" is an "CalendarFactoryBean" type object. Is it possible to injection "CalendarFactoryBean" object into "time" attribute?<br><br> 
Yes when IOC container instantiating the "calendar" bean it takes the class of it "CalendarFactoryBean" and starts instantiating while creating the object of CalendarFactoryBean it will notice this is implementing from FactoryBean interface, by which it will understand this class is meant for making other class objects as beans, so it understands that, programmer want me to create the object returned by the FactoryBean as bean. So, it calls the getObject() method on the CalendarFactoryBean class and calls the isSingleton method. Based on the isSingleton the object will be placed as bean in the IOC container with the name "calendar". Here bean calendar refers to "Calendar" class object that is created by CalendarFactoryBean, hence it should be able to perform injection.</p>  
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Method Replacement</span></div>
<p>There are many cases in an application we want to replace the logic inside a method with new logic. To replace the logic we can use multiple ways</p>  
<ol>
<li>Comment the logic inside the existing method and write the new logic as part of it </li>
<li>Write one more class extending the existing class and override the method and write the new logic </li>
</ol>  
<p>If you observe in the above two mechanisms we need to modify the existing source of the application. This pulls lot of questions</p> 
<ol>
<li> What if the new logic we are implementing has not certainty (not guaranteed to work)? </li>
<li> Sometimes we want to implement the new logic in experimental way.</li>
</ol> 
<p>If the new logic we are writing has uncertainty or experimental after writing the logic by modifying the existing source, it needs to be tested and should be deployed. But if after moving into production if the logic is not working then to revert the logic back to original again it needs to modify as we modified it has to be tested and should be redeployed. This incurs the cost equal to writing a new logic, just to revert back to the earlier logic which is a severe loss to the client.<br><br> 
So, if we manage to replace the logic inside the application without modifying the existing code inside the application, then if new logic is failing reverting to the old will not incurs cost as we haven’t touched the existing code.<br><br> 
This can be done through the Method replacement. For replacing a method on a bean the method should not be final and should not be static. In order to replace the method logic, you need to write new class which implement from MethodReplacer interface and should override reimplement method.<br><br> 
The reimplement method takes Object target, java.lang.Method method and Object[] arguments as parameters. These parameters are the values with which you called the original method.<br><br> 
We can replace the logic of a method with new, only when we have information about the original method and its inputs with which we called it. So if we look at the signature of the reimplement, it has the parameters as Object pointing to the actual object with which we called, Method points to the method we are replacing and Object[] args contains the inputs we passed to actual method.<br><br> 
Using the inputs now we can implement the logic to replace the actual as shown below</p> 
<pre ><code class="language-java">package com.mr.beans; 
public class PlanFinder {  
public String findPlans(int age, String zipCode, int coverageType,    
                                                   int networkType) 
return "Jeevan Anand";  
} 
public String findPlans(int age, String zipCode) {   
return "Jeevan Abhaya";  
} 
} </code></pre>
<pre ><code class="language-java">package com.mr.replacer; 
import java.lang.reflect.Method; 
import org.springframework.beans.factory.support.MethodReplacer; 
public class FindPlansReplacer implements MethodReplacer { 
@Override  public Object reimplement(Object target, Method method, Object[] args)    throws Throwable {   
if (method.getName().equals("findPlans")) {    
System.out.println("age : " + args[0]);    
System.out.println("zipCode : " + args[1]);    
System.out.println("coverageType : " + args[2]);    
System.out.println("networkType : " + args[3]); 
// complex logic to replace actual method here    return "Jeeval Saral";   
}   
return null;  
} 
}  </code></pre>
<p>By writing the FindPlansReplacer class by implementing MethodReplacer the logic will not gets replaced rather we need to instruct the IOC container while creating the object of PlanFinder bean to replace the logic with reimplement as below.</p> 
<pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
&ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">  
&ltbean id="planFinder" class="com.mr.beans.PlanFinder">   
&ltreplaced-method name="findPlans" replacer="findPlanReplacer"/>  
&lt/bean>  &ltbean id="findPlanReplacer" class="com.mr.replacer.FindPlansReplacer" /> 
&lt/beans> </code></pre>
<pre ><code class="language-java">package com.mr.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.mr.beans.PlanFinder; 
public class MRTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/mr/common/application-context.xml"));   
PlanFinder pf = factory.getBean("planFinder", PlanFinder.class);   
String plan = pf.findPlans(10, "11111", 1, 0);   
System.out.println("Plan : " + plan);  
} 
} </code></pre>
<p>Spring will replaces the findPlan method logic with reimplement method of findPlanReplacer at runtime by generating a new class extending from PlanFinder class and override the method findPlan with the logic that is there in reimplement method.<br><br> 
In order to replace the logic and to generate new class spring uses CGLIB runtime byte code generation libraries.<br><br>  
We need to remember some best practices while working with MethodReplacement </p> 
<li>It is good to have if condition to check whether the method we want to replace is right one or not. This makes code more clear and avoids configuration issues</li>
<li>For every method we want to replace we need to use a separate replacer class, we should not replace multiple methods with the same replacer even it is technically possible also</li> 
<p>If our class contains overloaded methods then in the &ltreplaced-method&gt tag when we specify the name as "findplans" it will not differentiate and replace the method rather it ignores replacing. To avoid this we can pass an extra &ltarg&gt tag inside the &ltreplaced-method&gt tag to tell the exact signature of the method want to replace as shown below.</p> 
<p>In case of Overloaded methods we can use the below configuration.</p>  
 <pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
 &ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"> 
&ltbean id="planFinder" class="com.mr.beans.PlanFinder">   
&ltreplaced-method name="findPlans" replacer="findPlanReplacer">    
&ltarg-type>int&lt/arg-type>    
&ltarg-type>java.lang.String&lt/arg-type>    
&ltarg-type>int&lt/arg-type>    
&ltarg-type>int&lt/arg-type>   
&lt/replaced-method>  
&lt/bean>  
&ltbean id="findPlanReplacer" class="com.mr.replacer.FindPlansReplacer" /> 
&lt/beans> </code></pre>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Lookup Method Injection</span></div>
<p>In spring when a non-singleton bean is getting injected into a singleton bean the result will be always singleton. For example if LoanApprover is a singleton class and LoanInfo is a non-singleton class. If we inject LoanInfo into LoanApprover class as shown below</p>
<pre ><code class="language-java">&ltbean id="loanApprover" class="com.lmi.beans.LoanApprover">  
&ltproperty name=”loanInfo” ref=”loanInfo”/> 
&lt/bean> &ltbean id="loanInfo" class="com.lmi.beans.LoanInfo" scope="prototype"/> 
</code></pre>
<p>As the loanApprover is a singleton class, only one object of LoanApprover will be created by core container and hence LoanInfo bean will be injected once via setter injection into LoanApprover class. This leads to LoanInfo as singleton.<br><br> 
Ideally speaking the above design is wrong, because if we want to declare a class as singleton, it should not contain any state. As the LoanApprover is using the LoanInfo, instead of injecting LoadInfo via setter or constructor injection, LoanApprover has to fetch the LoanInfo from the container and should use and dispose it.<br><br> 
The below table depicts the matrix of combinations of single-ton and non-singleton</p>
<img src="../images/three1.jpg" width="100%" height="200px">
<p>Let's try to understand this better by taking one more example. The Web container upon receiving a request from the client, it will try to process the request by creating a new Object of RequestHandler class and populates the request data to RequestHandler.<br><br> 
If you observer the above scenario, here the Web container is a singleton class and RequestHandler is a non-singleton class, for every incoming request to the container it has to create a new RequestHandler class object and populate the request info and then should handover the control to process the request. So, the Web container will fetch the RequestHandler (so that each lookup of request handler will returns new object) class object upon receiving the request and populates data to process.<br><br> 
The Web Container class can fetch the Object of RequestHandler by implement BeanFactoryAware and can call getBean method to get the RequestHandler object shown below</p>
<pre ><code class="language-java">package com.lmi.beans; 
public class WebContainer implements BeanFactoryAware {  
private BeanFactory factory; 
public void process(String data) {   
RequestHandler rh = factory.getBean("requestHandler", RequestHandler.class);   
rh.setData(data);   
rh.handle();  
} 
public void setBeanFactory(BeanFactory factory) {   
this.factory = factory;  
} 
} </code></pre>
<p>In the above code we have used factory.getBean("requestHandler"), this indicates that we have hardcoded the logical name of the bean in our code, so that our code is tightly coupled with that specific bean. Second issue with that code is we have implemented our code from spring specific interface which indicates we lose the benefit of noninvasive feature of spring.<br><br> 
To avoid the above problems we need to use Lookup Method Injection. In this your class doesn't need to implement from any spring specific class or interface. You don’t need to code for getting the reference of dependent object. Instead you declare to spring asking it to write the code of getting the dependent object through configuration, so that your code is loosely coupled with a spring bean. This is shown in the below example.</p>  
<p  style="font-weight:bold;color:#212121">WebContainer.java</p>
<pre ><code class="language-java">package com.lmi.beans; 
abstract public class WebContainer {  
public void process(String data) {   
RequestHandler rh = getRequestHandler();   
rh.setData(data);   rh.handle();  
} 
abstract public RequestHandler getRequestHandler(); 
} </code></pre>
<p  style="font-weight:bold;color:#212121">RequestHandler.java</p>
<pre ><code class="language-java">package com.lmi.beans; 
public class RequestHandler {  
private String data;    
public void setData(String data) {   
this.data = data;  
} 
public void handle() {  
System.out.println("Processing request with data : " + data); 
} 
} </code></pre>  
<p>In the above code we declared a method getRequestHandler() as a abstract method which returns RequestHandler object. We don't know how to write the logic in this method to get the RequestHandler object, so we declared this as abstract asking spring to implement this method for us. We will tell spring to implement the getRequestHandler method in configuration as shown below. </p>  
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="requestHandler” class=”com.lmi.beans.RequestHandler" scope="prototype"/> 
&ltbean id="webContainer" class="com.lmi.beans.WebContainer">  
&ltlookup-method name="getRequestHandler” bean=”requestHandler"/> 
&lt/bean> </code></pre>  
<p>In the above declaration we declared lookup method tag in WebContainer bean stating spring to implement the method getRequestHandler to return the requestHandler bean.<br><br> 
So your code has to call the getRequestHandler method to get the object of it. Spring will generates a class at runtime by using CGLib libraries and overrides this method to return the RequestHandler object</p> 
<p>There are few things we need to remember as part of this</p>  
<li>We should not go for injection when our Target bean is singleton and our dependent beans is prototype</li>
<li>Even a class is abstract also we can declare it as a bean in spring bean configuration file, if the abstract method is declared as lookup method.</li> 
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Property Editors</span></div>
<p>In spring when you configure a class as spring bean, you can inject all the dependent attributes of the bean via setter or constructor injection. The attributes that you want to inject via spring injection could be of any type like int, float, long, any arbitrary object, String[], File etc.<br><br> 
Spring when you configure an attribute value using &ltproperty&gt tag, the value will be converted into class attribute type by using the property editor and then injects into the bean.<br><br> 
So there are lot of in-built property editors that are available in spring which converts the string values you configured in the configuration file to the target bean attribute types. For example when you configure a file path as string in &ltproperty&gt or &ltconstructor-arg&gt tag it will be injected as a File object into the target class attribute using the file path. So these types of conversions will be done using PropertyEditor as shown below.</p>
<pre ><code class="language-java">package com.pe.beans; 
import java.io.File; 
import java.util.Arrays; 
import java.util.Date; 
public class Payslip {  
private int empId;  
private String name;  
private Date paidDt;  
private File paySlipFile;  
private String[] verifiers; 
// setters and getters 
@Override  public String toString() {   
return "Payslip [empId=" + empId + ", name=" + name + ", paidDt="     
             + paidDt + ", paySlipFile=" + paySlipFile + ", verifiers="     
                  + Arrays.toString(verifiers) + "]";  
} 
} </code></pre>
<pre ><code class="language-java">&lt?xml version="1.0" encoding="UTF-8"?> 
&ltbeans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">  
&ltbean id="payslip" class="com.pe.beans.Payslip">   
&ltproperty name="empId" value="10" />   
&ltproperty name="name" value="john" />   
&ltproperty name="paidDt" value="02/10/2014" />   
&ltproperty name="paySlipFile" value="C:\axis-1_4\README"/>   
&ltproperty name="verifiers" value="rama,laxmana"/>  
&lt/bean> 
&lt/beans> </code></pre>
<pre ><code class="language-java">package com.pe.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.pe.beans.Payslip; 
public class PETest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/pe/common/application-context.xml"));   
Payslip ps = factory.getBean("payslip", Payslip.class);   
System.out.println(ps);  
} 
} </code></pre>
<p>As we understood the purpose of PropertyEditor, let's try to understand how to create our own custom property editor by taking an example.</p>  
<p  style="font-weight:bold;color:#212121">ComplexNumber.java</p>
<pre ><code class="language-java">package com.pe.beans; 
public class ComplexNumber {  
private int base;  private int expo;  
public ComplexNumber(int base, int expo) {   
this.base = base;   this.expo = expo;  
}  
public int getBase() {   
return base;  
}  
public void setBase(int base) {   
this.base = base;  
}  
public int getExpo() {   
return expo;  
}  
public void setExpo(int expo) {   
this.expo = expo;  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">MathCalculator.java</p>
<pre ><code class="language-java">package com.pe.beans; 
public class MathCalculator {  
private ComplexNumber complexNumber; 
public void setComplexNumber(ComplexNumber complexNumber) {   
this.complexNumber = complexNumber;  
} 
public void calculate() {   
System.out.println("Calculating with complex number base : "     
            + complexNumber.getBase() + " expo : "     + complexNumber.getExpo());  
} 
}  </code></pre>
<p>In order to inject ComplexNumber into MathCalculator, the configuration looks as follows.</p>
 <p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id=”complexNumber” class=”com.pe.beans.ComplexNumber”>  
&ltproperty name="base" value="24"/>  
&ltproperty name="expo" value="34"/> 
&lt/bean> &ltbean id="mathCalculator" class="com.pe.beans.MathCalculator">  
&ltproperty name="complexNumber" ref="complexNumber"/> 
&lt/bean>  </code></pre>  
<p>The above configuration works without any issue, but instead of configuring the complexNumber as a bean and injecting via property reference, we want to configure the complexNumber as a String literal value as 24, 34 where 24 is the base and 34 is the expo as shown below.</p>  
<pre ><code class="language-java">&ltbean id="mathCalculator" class="com.pe.beans.MathCalculator">  
&ltproperty name="complexNumber" value="24,34"/> 
&lt/bean> </code></pre>
<p>In order to achieve the above, we need to write a custom property editor which will reads the string value "23, 34" in the configuration and coverts it to the target class attribute type, in this case ComplexNumber type and injects it. 
So, to develop a custom property editor you need to write a class which extends from PropertyEditorSupport and should register this with the BeanFactory as shown below. </p>  
<p  style="font-weight:bold;color:#212121">ComplexNumberEditor.java </p>
<pre ><code class="language-java">package com.pe.beans; 
import java.beans.PropertyEditorSupport; 
public class ComplexNumberEditor extends PropertyEditorSupport { 
@Override  public void setAsText(String value) throws IllegalArgumentException {   
int base = 0;   
int expo = 0; 
base = Integer.parseInt(value.substring(0, value.indexOf(",")));   
expo = Integer.parseInt(value.substring(value.indexOf(",") + 1,     value.length()));   
ComplexNumber complexNumber = new ComplexNumber(base, expo);   
setValue(complexNumber);  
} 
} </code></pre>  
<p>After developing a custom property editor class, you need to register this with the BeanFactory after creating the factory shown below</p> 
<p  style="font-weight:bold;color:#212121">PETest.java</p>
<pre ><code class="language-java">package com.pe.test; 
import org.springframework.beans.PropertyEditorRegistrar; 
import org.springframework.beans.PropertyEditorRegistry; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.pe.beans.ComplexNumber; import com.pe.beans.ComplexNumberEditor; 
import com.pe.beans.MathCalculator; 
public class PETest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/pe/common/application-context.xml")); 
((ConfigurableListableBeanFactory) factory)     .
addPropertyEditorRegistrar(new PropertyEditorRegistrar() { 
@Override      
public void registerCustomEditors(        
PropertyEditorRegistry registry) {       
registry.registerCustomEditor(ComplexNumber.class,new ComplexNumberEditor());      
}     
});   
MathCalculator mc = factory.getBean("mathCalculator", MathCalculator.class);   
mc.calculate();  
} 
} </code></pre>  
<p>So, after creating the Custom Property editor we need to register that with the PropertyEditorRegistry. PropertyEditorRegistry is an internal object in the IOC container so we wrote a class implementing PropertyEditorRegistrar and overridden the method. We registered the PropertyEditorRegistrar as a registrar to the container. So, container will automatically class the registerCustomeEditors by passing the registry using which we can register our custom property editors.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Internationalization (i18n)</span></div>
<p>Internationalization is the process of designing the application to adapt and display the content specific to the locale from which the user is accessing from.<br><br> 
JEE has support for designing internationalized applications. It has provided a class "ResourceBundle", it takes the base bundle name and locale and retrieves the values from the locale specific property files.<br><br> 
Here is the sample snipped of code showing the same</p> 
<p  style="font-weight:bold;color:#212121">messages.properties</p>
<pre ><code class="language-java">HOME_WELCOME_MSG=Welcome to my application </code></pre>
<p  style="font-weight:bold;color:#212121">messages_cn_CH.properties</p>
<pre ><code class="language-java">HOME_WELCOME_MSG=HELLO </code></pre> 
<p>We created two properties file with key as HOME_WELCOME_MSG one containing value as English and other one in Chinese language. Now based on the locale from which the user is accessing we will pull the value from appropriate locale specific bundle and display as part of application as shown below.</p> 
<pre ><code class="language-java">ResourceBundle rb = ResourceBundle.getBundle("messages", Locale.geDefault()); 
String message = rb.getMessage("HOME_WELCOME_MSG"); 
System.out.println(message); </code></pre>
<p>There are lots of problems with JEE approach in working with Internationalization as described below</p>
<li>To display content in a Jsp page we should not hardcode rather should read the text from Message Bundles (properties) files and should display the content. This means we have to create the "ResourceBundle" object across the servlet's and should make it available to the Jsp by binding to request scope. But with this we end up in writing the code across all the classes of our application, instead we can write a filter which creates the "ResourceBundle" and make it available for all the requests. This indicates programmer has to decide the strategy of using the ResourceBundle object in the application</li>
<li>An application cannot be completed with one properties file, we may need to externalize the values across multiple properties files. If we have multiple properties file we need to create one ResourceBundle object per Properties file to read the values. This leads to referring multiple ResourceBundle objects across the application to retrieve values from different properties files</li>
<li>Sometimes in an application we want to read the value for a key in multiple Locale bundles. To read the same message in different languages, we need to create one ResourceBundle object per locale. In this case also we have to refer more ResourceBundle objects in application</li>
<p>Spring has a better support for internationalization when compared with JEE internationalization. It has provided multiple classes like StaticMessageBundleSource, ResourceBundleMessageSource and ReloadableMessageSource. These take multiple properties files as inputs and will retrieve the messages from various properties.</p> 
<p>As we are going to configure this as a bean, by default it is singleton, so for entire application we will have only one object of this. And these classes has a method getMessage and it takes the "key" and Locale as a parameter. This indicates the message can be read from different locales without creating multiple objects.<br><br>  
Now instead of directly reading the messages from these classes we can read the messages from ApplicationContext as well. This is one of the differences between ApplicationContext and BeanFactory. BeanFactory doesn’t have internationalization support only ApplicationContext has. 
Spring has provided methods to access the messages from the resource bundle in ApplicationContext. Now we can call convienent method getMessage() on application context in turn reads the messages using the help of the above mentioned classes. In the ApplicationContext, it declared an attribute messageSource of type ResourceBundleMessageSource as shown below. 
So in order to load properties file you need to declare a bean whose type is ResourceBundleMessageSource, it will takes an attribute baseName, for which you need to pass the name of the properties file. This bean has to be named with messageSource so that when we call getMessage() method on ApplicationContext, it delegates the call to the bean whose name is "messageSource" to get the messages. 
Note: -You have to place the properties file under classes’ folder (place it in src, will automatically shipped as part of classes)</p>  
<p  style="font-weight:bold;color:#212121">application-context.xm</p>
<pre ><code class="language-java">&ltbean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">  
&ltproperty name="basename" value="label"/> 
&lt/bean> </code></pre>
<p  style="font-weight:bold;color:#212121">I18NTest.java</p>
<pre ><code class="language-java">package com.i18n.test; 
import java.util.Locale; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
public class I18NTest {   
public static void main(String[] args) {   
ApplicationContext context = new ClassPathXmlApplicationContext(     
"com/i18n/common/application-context.xml");   
System.out.println("Message : "     + context.getMessage("empid.label", new Object[] {
"is not", "valid"}, Locale.getDefault()));  
} 
} </code></pre>  
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Post Processor</span></div>
<p>In spring, we use Bean Lifecycle to perform initialization on a bean. But using initmethod, destroy-method or InitializingBean, DisposableBean we do initialization or destruction process for a specific bean which implement these.<br><br> 
If we have a common initialization process which has to be applied across all the beans in the configuration, Bean lifecycle cannot handle this. We need to use BeanPostProcessor.<br><br> 
BeanPostProcessor has two methods postProcessBeforeInitialization and postProcessAfterInitialization, these methods will be invoked for all the beans on the core container. postProcessBeforeInitialization method will be called after the core container has created the bean and before it performs injection. postProcessAfterInitialization method will be called after the core container has perfomed injections. For both of these methods the bean will be passed as parameter along with beanName on which the methods are fired.<br><br> 
In these methods the developer can write the Initialization logic to initialize the beans. So, you need to write a class which implements from BeanPostProcessor interface and override the methods and provide the logic for initialization. The same has been depicted in the below example</p>  
<p  style="font-weight:bold;color:#212121">EmployeeDelegate.java</p>
<pre ><code class="language-java">package com.bpp.beans; 
abstract public class EmployeeDelegate {  
private EmployeeVO employeeVO;  
private EmployeeDao employeeDao; 
public void insert() {                    
employeeVO = lookupEmployeeVO();   
employeeVO.setEmpID("E32542");   
employeeVO.setName("John");   
employeeVO.setSalary(353.34f);   
employeeDao.insert(employeeVO);  } 
public abstract EmployeeVO lookupEmployeeVO(); 
public void setEmployeeDao(EmployeeDao employeeDao) {   
this.employeeDao = employeeDao;  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">EmployeeDao.java</p>
<pre ><code class="language-java">package com.bpp.beans; 
public class EmployeeDao {  
public void insert(EmployeeVO employeeVO) {   
System.out.println("inserting employee : "     
+ employeeVO.getLastModifiedDate());  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">EmployeeVO.java </p>
<pre ><code class="language-java">package com.bpp.beans; 
public class EmployeeVO extends BaseVO {  
private String empID;  
private String name;  
private float salary; 
// setters and getters 
} </code></pre>
<p  style="font-weight:bold;color:#212121">BaseVO.java</p>
<pre ><code class="language-java">package com.bpp.beans; 
import java.util.Date; 
abstract public class BaseVO {  
private Date lastModifiedDate; 
public Date getLastModifiedDate() {   
return lastModifiedDate;  } 
public void setLastModifiedDate(Date lastModifiedDate) {   
this.lastModifiedDate = lastModifiedDate;  
} 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">BaseVOBeanPostProcessor.java </p>
<pre ><code class="language-java">package com.bpp.beans; 
import java.util.Date; 
import org.springframework.beans.BeansException; 
import org.springframework.beans.factory.config.BeanPostProcessor; 
public class BaseVOPostProcessor implements BeanPostProcessor { 
@Override  public Object postProcessAfterInitialization(Object bean, String beanName)    throws BeansException {   
if (bean instanceof BaseVO) {    
((BaseVO) bean).setLastModifiedDate(new Date());   
}   
return bean;  
} 
@Override  public Object postProcessBeforeInitialization(Object arg0, String arg1)    throws BeansException {   
return arg0;  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="employeeVO" class="com.bpp.beans.EmployeeVO" scope=”prototype”/> 
&ltbean id="employeeDao" class="com.bpp.beans.EmployeeDao" /> 
&ltbean id="employeeDelegate" class="com.bpp.beans.EmployeeDelegate">  
&ltlook-up-method name=”lookupEmployeeVO” bean=”employeeVO”/>  
&ltproperty name="employeeDao" ref="employeeDao" /> 
&lt/bean> 
&ltbean id="bpp" class="com.bpp.beans.BaseVOPostProcessor"/> </code></pre>
<p>Once you create the BeanPostProcessor class, you need to register the postprocessor with the bean factory as shown below.</p>
<p  style="font-weight:bold;color:#212121">BPPTest.java</p>
<pre ><code class="language-java">package com.bpp.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.bpp.beans.BaseVOPostProcessor; import com.bpp.beans.EmployeeDelegate; 
public class BPPTest { 
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/bpp/common/application-context.xml"));   
BaseVOPostProcessor bpp = factory.getBean("bpp",     BaseVOPostProcessor.class); 
((ConfigurableListableBeanFactory) factory).addBeanPostProcessor(bpp);   
EmployeeDelegate ed = factory.getBean("employeeDelegate", EmployeeDelegate.class);   
ed.insert();  
} 
} </code></pre>  
<p>So, in the above code after registering the bean postprocessor, when you try to fetch the EmployeeDelegate bean from the core container, while creating the delegate it will try to create EmployeeVO and EmployeeDao to inject into it. 
So after the container creates these before performing injection it will call the postProcessBeforeInitialization and after performing the injection, it will call postProcessAfterInitialization.</p>  
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Factory Post Processor</span></div>
<p>If we want to perform some post processing on the BeanFactory after it has been created and before it instantiates the beans then we need to go for BeanFactoryPostProcessor.<br><br>  
If we want to change the configuration, we can always change it by modifying the physical configuration file. Instead if want to modify the configuration dynamically at runtime within the IOC container metadata then we can use BeanFactoryPostProcessor.<br><br> 
There are many benefits of using BeanFactoryPostProcessors. We can modify the configuration during the deployment time by using some build tools like ant. But if we want to modify the configuration again it demands the rebuild and redeployment. Instead if we go for BeanFactoryPostProcessor as the configuration is modified in the IOC container metada at runtime.<br><br> 
If we want to perform post initialization after creating the BeanFactory and before creating the beans, we need to use BeanFactoryPostProcessor. It’s a one of the kind of extension hooks that spring has provided to the developer to perform customizations on the configuration that is loaded by the Factory.<br><br> 
Spring has provided built-in BeanFactoryPostProcessor’s to perform post processing, based on the type of post processor you use, you will get the respective behavior in your application. One of it is PropertyPlaceHolderConfigurer.<br><br> 
PropertyPlaceHolderConfigurer is a post processor which will reads the messages from the properties file and replaces the ${} place holder's of a bean configuration after the BeanFactory has loaded it.</p> 
<p  style="font-weight:bold;color:#212121">ConnectionManager.java </p>
<pre ><code class="language-java">package com.bfpp.beans; 
public class ConnectionManager {  
private String url;  
private String userName;  
private String password;    
// setters & getters  </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml </p>
<pre ><code class="language-java">&ltbean id="connectionManager" class="com.bfpp.beans.ConnectionManager">  
&ltproperty name="url" value="${db.url}"/>  
&ltproperty name="userName" value="${db.un}"/>  
&ltproperty name="password" value="${db.pwd}"/> 
&lt/bean> </code></pre>  
<p>If you create a BeanFactory with the above configuration, the ConnectionManager bean will gets created with url, username and password with ${} token values. Instead of this, if we want to replace the ${} values with property file key values, we need to configure PropertyPlaceHolderConfigurer. This post processor after loading the configuration by BeanFactory and before the factory creates the ConnectionManager bean, will replaces the ${} values with property key values as shown below. </p>  
<p  style="font-weight:bold;color:#212121">db.properties</p>
<pre ><code class="language-java">db.url=jdbc:odbc:thin@1521:XE db.un=weblogic db.pwd=welcome1 </code></pre>  
<p>Adding to the above configuration, you need to configure the post processor and register this with the BeanFactory.</p>  
<pre ><code class="language-java">&ltbean id="pphc" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
&ltproperty name="location" value="classpath:db.properties"/> 
&lt/bean </code></pre>
<p  style="font-weight:bold;color:#212121">BFPPTest.java</p>
<pre ><code class="language-java">package com.bfpp.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.config.BeanFactoryPostProcessor; 
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.bfpp.beans.ConnectionManager; 
public class BFPPTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/bfpp/common/application-context.xml"));   
BeanFactoryPostProcessor bfpp = factory.getBean("pphc", BeanFactoryPostProcessor.class);   
bfpp.postProcessBeanFactory((ConfigurableListableBeanFactory)factory);      
ConnectionManager cm = factory.getBean("connectionManager", ConnectionManager.class);   
System.out.println("cm.url : " + cm.getUrl());  
} 
} 
</code></pre>  
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Event Processing</span></div>
<p>Spring provides Event handling capabilities using the ApplicationContext. For any event based processing technic we have four actors, 1) source 2) event 3) event listener and 4) event handler.<br><br> 
Source is the actor who raises an Event, Event is the class which contains the data representing the purpose of the event. Listener is the person who will listens for the event, and upon raising the event by source, listener will catches it and raises a method call on the handler to process that event.<br><br> 
So, Event handling is used for asynchronous processing, in spring an Event is represented with ApplicationEvent, Listener is created using ApplicationListener, and the application listener will contains the method onApplicationEvent() which will be fired upon raising the Event. In order to publish an event, the source needs an ApplicationEventPublisher. The below example shows the same.</p>
<p  style="font-weight:bold;color:#212121">RefreshEvent.java</p>
<pre ><code class="language-java">package com.ep.beans; 
import org.springframework.context.ApplicationEvent; 
public class RefreshEvent extends ApplicationEvent {  
private String tableName; 
public RefreshEvent(Object source, String tableName) {   
super(source);   
this.tableName = tableName;  } 
public String getTableName() {   
return tableName;  
} 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">RefreshEventListener.java</p>
<pre ><code class="language-java">package com.ep.beans; 
import org.springframework.context.ApplicationListener; 
public class RefreshEventListener implements ApplicationListener&ltRefreshEvent&gt { 
@Override  public void onApplicationEvent(RefreshEvent event) {   
System.out.println("Refreshing table : " + event.getTableName());  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">RefreshEventSource.java</p>
<pre ><code class="language-java">package com.ep.beans; 
import org.springframework.context.ApplicationEventPublisher; 
import org.springframework.context.ApplicationEventPublisherAware; 
public class RefreshEventSource implements ApplicationEventPublisherAware {  
private ApplicationEventPublisher publisher;    
public void raiseRefresh(String table) {   
publisher.publishEvent(new RefreshEvent(this, table));  
}    
@Override  public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {   
this.publisher = publisher;  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean class="com.ep.beans.RefreshEventListener"/> 
&ltbean id="refreshEventSource" class="com.ep.beans.RefreshEventSource"/> </code></pre>
<p  style="font-weight:bold;color:#212121">EPTest.java </p>
<pre ><code class="language-java">package com.ep.test; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
import com.ep.beans.RefreshEventSource; 
public class EPTest {  
public static void main(String[] args) {   
ApplicationContext context = new ClassPathXmlApplicationContext(     
"com/ep/common/application-context.xml"); 
RefreshEventSource res = context.getBean("refreshEventSource",     RefreshEventSource.class);   
res.raiseRefresh("TBLEMPLOYEE");  
} 
} </code></pre>  
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Factory VS Application Context</span></div>
<table>
<th>Bean Factory</th>
<th>Application Context</th>  
  <tr>
    <td>
<li>Bean Factory is a lazy initializer, this means after creating the Bean Factory, it will loads the configuration file but will not create any beans for the bean declarations. When you try to fetch the bean by using factory.getBean(""), Bean Factory will creates the bean</li>
<li>Bean Factory doesn't support Internationalization.</li>
<li>Bean Factory doesn't supports Event Handling and Event processing</li>
<li>Bean Factory will not automatically registers BeanPostProcessors or BeanFactoryPostProcessors, we need to explicitly write the code for registering them</li>	
</td>
<td>
<li>ApplicationContext is an eager initializer. When you first create the application context with the configuration, after loading the configuration, it will immediately create all the beans in the configuration.</li>
<li>Application Context supports internationalization.</li>
<li>Application Context supports Event processing.</li>
<li>Application Context up seeing the BeanPostProcessor and BeanFactoryPostProcessor declarations in the configuration, will automatically registers them with the container and applies processing</li>	
</td>
</tr>
</table>  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>
</div>
<script>var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var r=n.util.type(e);switch(t=t||{},r){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a={};t[n.util.objId(e)]=a;for(var l in e)e.hasOwnProperty(l)&&(a[l]=n.util.clone(e[l],t));return a;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a=[];return t[n.util.objId(e)]=a,e.forEach(function(e,r){a[r]=n.util.clone(e,t)}),a}return e}},languages:{extend:function(e,t){var r=n.util.clone(n.languages[e]);for(var a in t)r[a]=t[a];return r},insertBefore:function(e,t,r,a){a=a||n.languages;var l=a[e];if(2==arguments.length){r=arguments[1];for(var i in r)r.hasOwnProperty(i)&&(l[i]=r[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in r)r.hasOwnProperty(i)&&(o[i]=r[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===a[e]&&t!=e&&(this[t]=o)}),a[e]=o},DFS:function(e,t,r,a){a=a||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],r||l),"Object"!==n.util.type(e[l])||a[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||a[n.util.objId(e[l])]||(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,a)):(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,a)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,r){var a={callback:r,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var l,i=a.elements||e.querySelectorAll(a.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,a.callback)},highlightElement:function(t,r,a){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),r&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,a){var l={code:e,grammar:t,language:a};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),r.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,r,a,l,i,o){var s=n.Token;for(var u in r)if(r.hasOwnProperty(u)&&r[u]){if(u==o)return;var g=r[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=a,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join("");var l={type:e.type,content:r.stringify(e.content,t,a),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:a};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.java=Prism.languages.extend("clike",{keyword:/\b(?:abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,number:/\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp-]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?[df]?/i,operator:{pattern:/(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,lookbehind:!0}}),Prism.languages.insertBefore("java","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}}),Prism.languages.insertBefore("java","class-name",{generics:{pattern:/<\s*\w+(?:\.\w+)?(?:\s*,\s*\w+(?:\.\w+)?)*>/i,alias:"function",inside:{keyword:Prism.languages.java.keyword,punctuation:/[<>(),.:]/}}});
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var e="line-numbers",t=/\n(?!$)/g,n=function(e){var n=r(e),s=n["white-space"];if("pre-wrap"===s||"pre-line"===s){var l=e.querySelector("code"),i=e.querySelector(".line-numbers-rows"),a=e.querySelector(".line-numbers-sizer"),o=l.textContent.split(t);a||(a=document.createElement("span"),a.className="line-numbers-sizer",l.appendChild(a)),a.style.display="block",o.forEach(function(e,t){a.textContent=e||"\n";var n=a.getBoundingClientRect().height;i.children[t].style.height=n+"px"}),a.textContent="",a.style.display="none"}},r=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener("resize",function(){Array.prototype.forEach.call(document.querySelectorAll("pre."+e),n)}),Prism.hooks.add("complete",function(e){if(e.code){var r=e.element.parentNode,s=/\s*\bline-numbers\b\s*/;if(r&&/pre/i.test(r.nodeName)&&(s.test(r.className)||s.test(e.element.className))&&!e.element.querySelector(".line-numbers-rows")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s," ")),s.test(r.className)||(r.className+=" line-numbers");var l,i=e.code.match(t),a=i?i.length+1:1,o=new Array(a+1);o=o.join("<span></span>"),l=document.createElement("span"),l.setAttribute("aria-hidden","true"),l.className="line-numbers-rows",l.innerHTML=o,r.hasAttribute("data-start")&&(r.style.counterReset="linenumber "+(parseInt(r.getAttribute("data-start"),10)-1)),e.element.appendChild(l),n(r),Prism.hooks.run("line-numbers",e)}}}),Prism.hooks.add("line-numbers",function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0}),Prism.plugins.lineNumbers={getLine:function(t,n){if("PRE"===t.tagName&&t.classList.contains(e)){var r=t.querySelector(".line-numbers-rows"),s=parseInt(t.getAttribute("data-start"),10)||1,l=s+(r.children.length-1);s>n&&(n=s),n>l&&(n=l);var i=n-s;return r.children[i]}}}}}();
!function(){"undefined"!=typeof self&&!self.Prism||"undefined"!=typeof global&&!global.Prism||Prism.hooks.add("wrap",function(e){"keyword"===e.type&&e.classes.push("keyword-"+e.content)})}();
</script>
</body>
</html> 
