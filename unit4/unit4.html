<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {height: 100%;
    margin: 0;
    
padding:5px;}
h3{
 
color:#212121;
}
h4{
color:#1b1b1b;
}
p,li{
  font-size: 16px;
color:#757575;
}
.card {
background-color:#ffffff;
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    transition: 0.3s;

}

.card:hover {
    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
}

.container {

    padding: 1px 8px;
}
code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	 font-size: 12px;
  line-height: 1.375;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;


	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #f8f8f2;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

pre.line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre.line-numbers > code {
	position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}
.tip {
    background-image: url(https://www.w3schools.in/wp-content/uploads/tip.png);
    padding: 10px 10px 10px 50px;
    background-position: 10px 20px;
    background-repeat: no-repeat;
	display: table;
    border: 2px solid #DDD;
    border-left: 3px solid #32cd32;
    margin-left: 0;


    border-radius: 3px;
}
.tip2{
  padding: 10px 10px 10px 10px;
    background-position: 10px 20px;
    background-repeat: no-repeat;
	display: table;
    border: 2px solid #DDD;
    border-left: 3px solid #32cd32;
    margin-left: 0;


    border-radius: 3px;

}

img {
    max-width: 100%;
    max-height: 100vh;
    height: auto;
}

table {
    font-family: arial, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
}

tr:nth-child(even) {
    background-color: #dddddd;
}

</style>
</head>
<body>


<div class="card">
 
  <div class="container">
  <h3>Spring Annotation Support</h3>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Introduction to J2EE Annotation</span></div>
<p>Annotation is the code about the code that is metadata about the program itself. In other words information about the code is provided at the source code. Annotations are parsed/processed by compilers, annotation-processing tools and also executed at runtime.<br><br> 
Annotations have been introduced in JDK 1.5. It allows the programmers to specify the information about the code at the source code level itself. There are several ways we can use annotations. Few helps in understanding the source code (like documentation assistance) @override is the annotation that will be used when we override a method from base class. This annotation doesn't have any impact on run-time behavior, rather it helps javadoc complier to generate documentation based on it.<br><br> 
Apart from these annotations we have another way in using annotations which assist source code generators to generate source code using them. If we take example as Web Services, in order to expose a class as web service, we need to mark the class as @WebService. This annotation would be read by a tool and generates class to expose that class as web service.<br><br> 
Along with this there is another way, where when you mark a class with annotation, the run-time engine will executes the class based on that annotation with which it marked. For example, when you mark a class with @EJB, the class would be exposed as Enterprise Java Bean by the container rather than a simple pojo.<br><br> 
By the above we can understand that using annotations, a programmer can specify the various behavioral aspects of your code like documentation, code generation and runtime behavior. This helps in RAPID application development where in instead of specifying the information about your code in xml configuration file, the same can be specified by marking your classes with annotations.<br><br> 
Note: - Always your annotation configuration will be overwritten with the xml configuration if provided.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Spring Annotation Support </span></div>
<p>Spring support to annotations is an incremental development effort. Spring 2.0 has a very little support to annotation, when it comes to spring 2.5; it has extended its framework to support various aspects of spring development using annotations. In spring 3.0 it started supporting java config project annotations as well.<br><br> 
The journey to spring annotations has been started in spring 2.0; it has added @Configuration, @Repository and @Required annotations. Along with this it added support to declarative and annotation based aspectj AOP.<br><br> 
In spring 2.5 it has added few more annotations @Autowired, @Qualifier and @Scope. In addition in introduced stereotype annotations @Component, @Controller and @Service.<br><br> 
In spring 3.0 few more annotations has been added like @Lazy, @Bean, @DependsOn etc. In addition to spring based metadata annotation support, it has started adoption JSR - 250 Java Config project annotations like @PostConstruct, @PreDestory, @Resource, @Inject and @Named etc.<br><br> 
The below table list spring supported and Java Config project supported annotations.  </p>    
<img src="../images/four1.jpg" width="100%" height="200px">
<p  style="font-weight:bold;color:#212121">Working with @Configuration and @Bean </p>
<p>Instead of declaring a class as spring bean in a configuration file, you can declare it in a class as well. The class in which you want to provide the configuration about other beans, that class is called configuration class and you need to annotate with @Configuration. In this class you need to provide methods which are responsible for creating objects of your bean classes, these methods has to be annotated with @Bean.<br><br>
Now while creating the core container, instead of using XMLBeanFactory, you need to create it using AnnotationConfigApplicationContext by passing the configuration class as input</p>
<p  style="font-weight:bold;color:#212121">AppConfig.java</p>
<pre ><code class="language-java">@Configuration public class AppConfig {   
@Bean   public MyService myService() {       
return new MyServiceImpl();   
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">MyService.java</p>
<pre ><code class="language-java">public class MyService {  
public void doSomeStuff() {   
// some dummy logic  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">ConfigurationTest.java</p>
<pre ><code class="language-java">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); 
MyService myService = ctx.getBean(MyService.class); 
myService.doSomeStuff(); </code></pre>
<p  style="font-weight:bold;color:#212121">Working with @Required</p>
<p>In spring 1.x onwards we have dependency check. For a bean if you want to detect unresolved dependencies of a bean, you can use dependency check. In this IOC container will check whether all the bean dependencies, which is expressed in its properties are satisfied or not. The problem with dependency check is you can’t impose restriction on a certain property, either you need to check the dependencies on all simple or object or all.<br><br> 
In 2.0, it has introduced an annotation @Required and dependency check has been completely removed in 2.5. Using @Required annotation you can make, a particular property has been set with value or not.</p>
<p  style="font-weight:bold;color:#212121">Engine.java</p>
<pre ><code class="language-java">package com.annotation.beans; 
public class Engine {  
private Integer id;  
private String type; 
public Integer getId() {   
return id;  
} 
@Required  public void setId(Integer id) {   
this.id = id;  
} 
public String getType() {   
return type;  
} 
public void setType(String type) {   
this.type = type;  
} 
}  </code></pre>
<p>You can use @Required on a setter level to mark it as mandatory. Simply using @Required annotation will not enforce the property checking, you also need to register an RequiredAnnotationBeanPostProcessor in the configuration file as shown below. </p>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="engine" class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  
&lt! - -if you don’t provide value for id, raises error - ->  
&ltproperty name="type" value="T1"/>  
&ltqualifier value="myengine"/> 
       &lt/bean> 
(&ltcontext:annotation-config/> 
(OR) 
&ltbean class= "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />)  </code></pre>
<p  style="font-weight:bold;color:#212121">Working with @Autowire</p>
<p>You can enable autowiring using @Autowire annotation rather than configuration approach. Unlike your declarative &ltbean autowire="byName/byType/constructor"/> etc, in annotation driven we don't have any modes.<br><br> 
In annotation based approach you may mark an attribute of a target class or a setter or a constructor or any arbitrary method for injecting the dependent object. In all the cases it will performs autowiring byType. 
@Autowired annotation has an attribute required=true (@Autowired(required=true)). By default required is true. When you use required=true, while creating the target class object it will try to find the appropriate dependent class object in IOC container, if it couldn't find one the container will throws exception without creating core container. 
At any point of time out of available number of constructors, you can mark only one constructor with @Autowired(required=true) and remaining should be set to false. 
Below examples shows various ways of using @Autowired</p>
<p  style="font-weight:bold;color:#212121">Attribute Level </p>
<pre ><code class="language-java">package com.annotation.beans; 
import org.springframework.beans.factory.annotation.Autowired; 
public class Motor {  
@Autowired(required=false)  
private Engine engine; 
public void run() {   
System.out.println("running with engine id : " + engine.getId());  
} 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">Setter Level</p>
<pre ><code class="language-java">(ignored few sections for clarity) 
public class Motor {  
private Engine engine; 
@Autowired(required=false)  
public void setEngine(Engine engine) {   
this.engine = engine;  
} 
…. }  </code></pre>
<p  style="font-weight:bold;color:#212121">Constructor Level</p>
<pre ><code class="language-java">(ignored few sections for clarity) 
public class Motor {  
private Engine engine; 
@Autowired(required=false)  
public Motor(Engine engine) {   
this.engine = engine;  
  } 
…. 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">Arbitrary method</p>
<pre ><code class="language-java">(ignored few sections for clarity) 
public class Motor {  
private Engine engine; 
@Autowired(required=false)  
public void newEngine(Engine engine) {   
this.engine = engine;  
} 
…. 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml </p>
<pre ><code class="language-java">&ltbean id="engine" class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  
&ltproperty name="type" value="T1"/> 
&lt/bean> 
&ltbean id="motor" class="com.annotation.beans.Motor"/> 
&ltcontext:annotation-config/> </code></pre>
<p>In order to detect @Autowire either you need to use &ltcontext:annotation-config/> or need to declare a bean whose class is  org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</p>
<p  style="font-weight:bold;color:#212121">Working with @Qualifier</p>
<p>If you have more than one beans of type Engine in the configuration, as @Autowire will perform injection byType, it will not be able to make the decision of which bean has to be injected and will raise ambiguity error. To resolve this we need to perform byName, this can be done with @Qualifier as shown below. </p>
<p  style="font-weight:bold;color:#212121">Using Qualifier</p>
<pre ><code class="language-java">(ignored few sections for clarity) 
public class Motor {  private Engine engine; 
@Autowired(required=false)  
@Qualifier("engine2")  
public void setEngine(Engine engine) {   
this.engine = engine;  
} 
…. 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="engine" class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  &ltproperty name="type" value="T1"/>  
&ltqualifier value="myengine"/> 
&lt/bean> 
&ltbean id=”maruthiengine” class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  
&ltproperty name="type" value="T1"/>  
&ltqualifier value="engine2"/> 
&lt/bean> 
&ltbean id="motor" class="com.annotation.beans.Motor"/> 
&ltcontext:annotation-config/> </code></pre>
<p>Only the bean whose qualifier value is "engine2" will be injected into Motor class engine attribute, so indirectly using @Qualifier we are able to perform byName injection. </p>
<p  style="font-weight:bold;color:#212121">Working with stereotype annotations @Component, @Repository, @Service and @Controlle</p>
<p>In addition to @Repository annotation in spring 2.0, spring 2.5 has added stereotype annotations @Component, @Service and @Controller to make your classes as spring beans.<br><br> 
When you mark you class with any of the above annotations those classes will be exposed as spring beans by the container. Based on the type of class you are trying to expose you need to use appropriate annotations.<br><br> 
@Component - This acts as a more generic stereotype annotation to manage any component by spring, whereas the other annotations are specialized for the specific use cases.<br><br> 
@Repository - This is used for exposing a DAO class as a spring bean. Even though database specific semantics are not imposed by using it, it helps you in applying exception translations on these @Repository classes using AOP.<br><br> 
@Service - The service layer class are annotated with @Service, even though the current release of the spring doesn't has any impact on using it (other than exposing that class as spring bean), but future releases of spring might add some specializations on those classes.<br><br> 
@Controller - When you mark a class with @Controller, it will be exposed as spring MVC controller to handle form submissions.<br><br> 
In a spring core/spring jdbc applications you can use @Component, @Service or @Repository whereas @Controller can be used only in a Spring MVC application.<br><br> 
The below examples shows how to use @Component, but you can mark that class with @Service or @Repository as well, where the end effect would be same. </p>
<p  style="font-weight:bold;color:#212121">Motor.java </p>
<pre ><code class="language-java">(ignored few sections for clarity) 
@Component("motor") public class Motor {  private Engine engine; 
@Autowired(required=false)  
public void setEngine(Engine engine) {   
this.engine = engine;  
} 
…. 
} </code></pre>
<p>With the above configuration, the class will be exposed as spring bean with id "motor". In order to detect the @Component or stereotype annotations you need to use the tag</p>
<p>&ltcontext:component-scan base-package="PKG NAME OF THE CLASSES"/> as shown below.</p>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltcontext:component-scan base-package="com.annotation.*"/> </code></pre>
<p>You can retrieve the bean with context.getBean("motor").</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Spring Java Config annotations</span></div>
<p>As explained earlier from spring 3.x it has added support to Java Config annotation support, this means when you mark you classes with any of the above discussed annotations like @Component or @Autowired, you classes will be tightly coupled with spring framework and will lose invasive feature of spring.<br><br> 
In order to retain loosely coupled feature, it spring has added support to java annotations, so when we use these annotations in spring applications, those will be read by spring container and add spring specific behavior to your classes. If you use in J2EE environment, those will behave based on container specification.</p>
<p  style="font-weight:bold;color:#212121">Working with @Inject</p>
<p>@Inject is a j2ee specific annotation, used for injecting/autowiring one class into another. This is more similar to @Autowired spring annotation. But the difference between them is @Autowire supports required attribute where @Inject doesn't has it.<br><br>  
@Inject also injects a bean into another bean byType as similar to @Autowired. The advantage of @Inject is it is from java (javax.inject package) which means even you separate your application from spring, still your classes can work with java rather than bounded to spring. </p>
<p  style="font-weight:bold;color:#212121">Motor.java</p>
<pre ><code class="language-java">(ignored few sections for clarity) 
@Component(“motor”) public class Motor {  
private Engine engine; 
@Inject  public void setEngine(Engine engine) {   
this.engine = engine;  
} 
…. 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">Working with @Named</p>
<p>There are two usages of @Named annotation</p>
<ol>
<li>When you try to inject a bean using @Inject annotation it will performs injection byType, if you have more than one beans of that type in the application, the container will throw ambiguity error. In order to resolve it you need to use @Named annotation</li>
</ol>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="engine" class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  
&ltproperty name="type" value="T1"/>  
&ltqualifier value="myengine"/> 
&lt/bean> 
&ltbean id="maruthiengine" class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  
&ltproperty name="type" value="T1"/> &lt/bean> 
&ltbean id="motor" class="com.annotation.beans.Motor"/> 
&ltcontext:component-scan base-package="com.annotation.*"/> </code></pre>
<p>In the above configuration you have two beans of type Engine, so when you try to inject the Engine into Motor by using @Inject, it will not be able to detect which bean has to be injected. So you need to mark the Engine attribute with @Named along with @Inject indicating the bean you want to inject show below.</p>
<p  style="font-weight:bold;color:#212121">Motor.java</p>
<pre ><code class="language-java">@Component("motor") 
public class Motor {  
private Engine engine; 
@Inject  @Named("maruthiengine") 
public void setEngine(Engine engine) {   
this.engine = engine;  
} 
…. 
} </code></pre>
<ol>
<li>Another use of @Named is instead of using the stereotype annotations of spring to expose your classes as spring beans, you can mark your class with @Named to expose it as spring bean show below.</li>
</ol>
<p  style="font-weight:bold;color:#212121">Motor.java</p>
<pre ><code class="language-java">@Named("motor") 
public class Motor {  
private Engine engine; 
@Inject  public void setEngine(Engine engine) {   
this.engine = engine;  
} 
…. 
} </code></pre>
<p  style="font-weight:bold;color:#212121">Instead of using @Inject, you can also use @Resource, the difference between @Inject and @Resource it @Inject will perform the injection byType where as @Resource will perform the injection byName.</p>
<p  style="font-weight:bold;color:#212121">Motor.java</p>
<pre ><code class="language-java">@Named("motor") public class Motor {  private Engine engine; 
 
 @Resource  public void setEngine(Engine engine) {   this.engine = engine;  } …. }  </code></pre>
<p>So, we need to have a bean whose id is "engine" in the configuration or with the component declaration with this name</p>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="engine" class="com.annotation.beans.Engine">  
&ltproperty name="id" value="22"/>  
&ltproperty name="type" value="T1"/>  
&ltqualifier value="myengine"/> 
&lt/bean> 
&ltcontext:component-scan base-package="com.annotation.*"/> </code></pre>
<p  style="font-weight:bold;color:#212121">Working with @PostConstruct and @PreDestroy </p>
<p>As we discussed, Bean Lifecycle you can perform Initialization on a bean after injecting the dependent objects using init-method declaration or InitializingBean interface afterPropertiesSet and Destruction on a bean while removing a bean from core container using destroy-method or DisposableBean interface destroy() method.<br><br> 
Along with the above two ways, you can mark any arbitrary method on a class with @PostContruct and @PreDestory annotations. When you mark a method with @PostConstruct annotation, this method will be invoked by core container after injecting the dependent objects into the bean. When you mark a method with @PreDestory annotation, this method will be invoked as part of bean destruction process.<br><br> 
So, the @PostContruct and @PreDestory or annotation based lifecycle methods</p>
<p  style="font-weight:bold;color:#212121">Motor.java</p>
<pre ><code class="language-java">@Named("motor") 
public class Motor {  
private Engine engine;    
@PostConstruct  public void init() {   
// I will be invoked after performing injection  
} 
@Resource  public void setEngine(Engine engine) {   
this.engine = engine;  
} 
@PreDestory public void release() {  
// I will be invoked while I am removing from container 
} 
…. 
} </code></pre>







































	
		
</div>
</div>
<script>var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var r=n.util.type(e);switch(t=t||{},r){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a={};t[n.util.objId(e)]=a;for(var l in e)e.hasOwnProperty(l)&&(a[l]=n.util.clone(e[l],t));return a;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a=[];return t[n.util.objId(e)]=a,e.forEach(function(e,r){a[r]=n.util.clone(e,t)}),a}return e}},languages:{extend:function(e,t){var r=n.util.clone(n.languages[e]);for(var a in t)r[a]=t[a];return r},insertBefore:function(e,t,r,a){a=a||n.languages;var l=a[e];if(2==arguments.length){r=arguments[1];for(var i in r)r.hasOwnProperty(i)&&(l[i]=r[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in r)r.hasOwnProperty(i)&&(o[i]=r[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===a[e]&&t!=e&&(this[t]=o)}),a[e]=o},DFS:function(e,t,r,a){a=a||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],r||l),"Object"!==n.util.type(e[l])||a[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||a[n.util.objId(e[l])]||(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,a)):(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,a)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,r){var a={callback:r,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var l,i=a.elements||e.querySelectorAll(a.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,a.callback)},highlightElement:function(t,r,a){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),r&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,a){var l={code:e,grammar:t,language:a};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),r.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,r,a,l,i,o){var s=n.Token;for(var u in r)if(r.hasOwnProperty(u)&&r[u]){if(u==o)return;var g=r[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=a,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join("");var l={type:e.type,content:r.stringify(e.content,t,a),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:a};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.java=Prism.languages.extend("clike",{keyword:/\b(?:abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,number:/\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp-]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?[df]?/i,operator:{pattern:/(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,lookbehind:!0}}),Prism.languages.insertBefore("java","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}}),Prism.languages.insertBefore("java","class-name",{generics:{pattern:/<\s*\w+(?:\.\w+)?(?:\s*,\s*\w+(?:\.\w+)?)*>/i,alias:"function",inside:{keyword:Prism.languages.java.keyword,punctuation:/[<>(),.:]/}}});
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var e="line-numbers",t=/\n(?!$)/g,n=function(e){var n=r(e),s=n["white-space"];if("pre-wrap"===s||"pre-line"===s){var l=e.querySelector("code"),i=e.querySelector(".line-numbers-rows"),a=e.querySelector(".line-numbers-sizer"),o=l.textContent.split(t);a||(a=document.createElement("span"),a.className="line-numbers-sizer",l.appendChild(a)),a.style.display="block",o.forEach(function(e,t){a.textContent=e||"\n";var n=a.getBoundingClientRect().height;i.children[t].style.height=n+"px"}),a.textContent="",a.style.display="none"}},r=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener("resize",function(){Array.prototype.forEach.call(document.querySelectorAll("pre."+e),n)}),Prism.hooks.add("complete",function(e){if(e.code){var r=e.element.parentNode,s=/\s*\bline-numbers\b\s*/;if(r&&/pre/i.test(r.nodeName)&&(s.test(r.className)||s.test(e.element.className))&&!e.element.querySelector(".line-numbers-rows")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s," ")),s.test(r.className)||(r.className+=" line-numbers");var l,i=e.code.match(t),a=i?i.length+1:1,o=new Array(a+1);o=o.join("<span></span>"),l=document.createElement("span"),l.setAttribute("aria-hidden","true"),l.className="line-numbers-rows",l.innerHTML=o,r.hasAttribute("data-start")&&(r.style.counterReset="linenumber "+(parseInt(r.getAttribute("data-start"),10)-1)),e.element.appendChild(l),n(r),Prism.hooks.run("line-numbers",e)}}}),Prism.hooks.add("line-numbers",function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0}),Prism.plugins.lineNumbers={getLine:function(t,n){if("PRE"===t.tagName&&t.classList.contains(e)){var r=t.querySelector(".line-numbers-rows"),s=parseInt(t.getAttribute("data-start"),10)||1,l=s+(r.children.length-1);s>n&&(n=s),n>l&&(n=l);var i=n-s;return r.children[i]}}}}}();
!function(){"undefined"!=typeof self&&!self.Prism||"undefined"!=typeof global&&!global.Prism||Prism.hooks.add("wrap",function(e){"keyword"===e.type&&e.classes.push("keyword-"+e.content)})}();
</script>
</body>
</html> 
