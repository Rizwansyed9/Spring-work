<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {height: 100%;
    margin: 0;
    
padding:5px;}
h3{
 
color:#212121;
}
h4{
color:#1b1b1b;
}
p,li{
  font-size: 16px;
color:#757575;
}
.card {
background-color:#ffffff;
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
    transition: 0.3s;

}

.card:hover {
    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
}

.container {

    padding: 1px 8px;
}
code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	 font-size: 12px;
  line-height: 1.375;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;


	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #f8f8f2;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

pre.line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre.line-numbers > code {
	position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}
.tip {
    background-image: url(https://www.w3schools.in/wp-content/uploads/tip.png);
    padding: 10px 10px 10px 50px;
    background-position: 10px 20px;
    background-repeat: no-repeat;
	display: table;
    border: 2px solid #DDD;
    border-left: 3px solid #32cd32;
    margin-left: 0;


    border-radius: 3px;
}
.tip2{
  padding: 10px 10px 10px 10px;
    background-position: 10px 20px;
    background-repeat: no-repeat;
	display: table;
    border: 2px solid #DDD;
    border-left: 3px solid #32cd32;
    margin-left: 0;


    border-radius: 3px;

}

img {
    max-width: 100%;
    max-height: 100vh;
    height: auto;
}

table {
    font-family: arial, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
}

tr:nth-child(even) {
    background-color: #dddddd;
}

</style>
</head>
<body>


<div class="card">
 
  <div class="container">
   <div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Spring Core (Basic)</span></div>
<p>Spring core is the foundation module of the spring framework, as we know to work on any other module in spring we need to know spring core. Why spring core is so important, what exactly spring core offers to us. Let us try to understand.<br><br> 
In an application we will have multiple classes; all the classes will not play the same role. Few classes are called Java beans, few are called pojo and some other are called component or bean classes.<br><br>  
Java bean: If a class only contains attributes with accessor methods (setters & getters) those are called java beans. These classes generally will not contain any business logic rather those are used for holding some data in it.<br><br> 
Pojo: If a class can be executed with underlying Jdk, without any other external third-party libraries support then it is called Pojo.<br><br> 
Component/Bean: If a class has attributes with some member methods. Those member methods may use the attributes of that class and will fulfill some business functionality then it is called Component classes.<br><br> 
So a project cannot be built by just one. Say with Java beans we cannot complete the project rather we need business logic to perform something, so component classes will also exist in a project.<br><br> 
So, in a project do we have one component class or multiple component classes. By just having one we cannot complete rather we will have multiple component classes. Every component class in our project will talk to other or will not? Every component class cannot be isolated; it has to talk to some other component classes in the project to fulfill the functionality</p>
<pre ><code class="language-java"> class A { 
 public void m1() {    
 }
 } 
 
class B {  
  public int m2() {   
  }
  }</code></pre>
  <p>In the above code we have class A and class B. class A m1() method may have to talk to m2() method of the class B to fulfill business functionality, so these two classes are called dependent on each other as, unless B is there A cannot be used. So how to make the B available to A or how to manage the dependencies between A and B is what spring core is all about.</p>
  <p>ow the question here is can I give any two classes and ask it to manage or spring cannot manage any arbitrary classes. Spring can manage any two arbitrary classes but in-order it to be effective spring recommends us to design our classes following some design guidelines, so that those components will be loosely-coupled. The spring can effective manage them.<br><br>  
Spring recommends us to design our classes following a design pattern called Strategy design pattern. Strategy design pattern is not belonging to spring, it is the pattern that comes from “Gang of four design patterns". If we design our classes following strategy design patterns the spring can manage them easily.<br><br>  
So, let's first examine the design principles and then we focus on Spring Core IOC.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Strategy pattern (Design principle spring recommends)</span></div>
<p>Strategy pattern lets you build software as loosely coupled collection of interchangeable parts, in contrast with tightly coupled system. This loosely coupling makes your software much more flexible, extensible, maintainable and reusable.<br><br> 
Strategy pattern recommends mainly three principles every application should follow to get the above benefits those are as follows </p>
<li>Favor Composition over Inheritance </li>
<li>Always design to Interfaces never code to Implementation</li>
<li>Code should be open for extension and closed for modification </li>
<p>Let us examine all the three principles by taking an example</p>
<p  style="font-weight:bold;color:#212121">Favor Composition over Inheritance </p> 
<p>Every class in order to perform a task has to talk with other class to get the things done. A class can use the functionality of other class in two ways. </p>
<ol>
<li>Through Inheritance - Inheritance is the process of extending one class from another class to get its functionalities. </li>
<li>Composition - A class will hold reference of other classes as attributes inside it</li>
</ol>
<p>Using Inheritance you always express relation between two classes as IS-A relationship. Composition always expresses relation between two classes as HASA relationship.<br><br> 
 When should I go for Inheritance and when should I go for composition?<br><br> 
 The problem with most of the programmers is they will always choose the option of inheritance to use the functionality of other classes. But this may not be apt in all cases;<br><br></p>
 <p>We have to go for inheritance only when all the behaviors (methods) of your base class can be commonly sharable across all the derived classes.<br><br>   
 
In case if my class wants to use only few behaviors of the other class, rather extending my class from the other I should go for composition.<br><br>  
 
If we look composition has more number of advantages when compared with inheritance as described below.</p>
<li>Most of the use-cases are solvable through composition rather than inheritance. If we look no class wants to use all the services of other class, rather it wants to use only few method of other class. Just for the sake of using few methods of other class we should not go for inheritance rather than composition is recommended </li>
<li>A class most of the time wants to use behavior of more than one classes, so to use the functionality of other class if we choose inheritance here we have to extend our class from more than one class. But most of the programming languages will not support extending a class from more than</li>
<li>one class (multiple inheritance). Only alternate here is to use composition.When we go for inheritance our classes will become fragile. Fragile means those will become delicate or easily breakable. To understand this let’s consider one example. I have a class A as shown below.</li>
<pre ><code class="language-java">class A {   
 int m1() {        
 // some logic     
 return 10;   
 }
 }</code></pre>
 <p>I have one more class B which extends from A and overriding method m1() as shown below. </p>
 <pre ><code class="language-java">class B extends A{  
 @Override    
 int m1() {       
 // some logic       
 int i = super.m1();       
 // calculate       
 return i;    
 } 
 }</code></pre>
 <p>Now class A has been written by some other developer and class B has been written by other developer. After sometime author of the class A has felt the return type of the method needs to be changed and has modified from int to float as shown below. </p>
 <pre ><code class="language-java"> class A {   
 float m1() {        
 // some logic       
 return 10.24;    
 } 
 } </code></pre>
 <p>Now author of the class A has changed the return type from int to float, immediately class B will not compile, why? When we are overriding the super class method and sub-class method signatures should be same. But in the super class for the method m1() return type is float and in sub-class the return type is int, so it is not an valid overriding.<br><br>  
 
Even it is not valid overloading, because parameters of my super class method m1() and parameters of my sub-class methods are same. It means we have two methods with same name in the class which is not allowed. So it results in compilation error.<br><br>  
 
Here the change in the super class will not just break the sub-class even the classes using the sub-class also will gets affected and all the components using your sub-class need to undergo changes. It results in high maintenance cost and chances of increasing the bugs will also be more.<br><br>  
 
If we go for composition in the above case which means class B is not extending from class A rather it is using the reference of A inside B to call its methods.</p>
<pre ><code class="language-java">class B {    
private A a; 
 
  int m1() {      
  // some logic      
  int i = a.m1();       
  // calculate       
  return i;    
  } 
  }  </code></pre>
  <p>Now if the return type of m1() in class A changed I just need to type cast the value in the B to int rather than modifying the return value as shown below. </p>
  <pre ><code class="language-java">class B {    
  private A a; 
   int m1() {      
   // some logic       
   int i =(float) a.m1();      
   // calculate       
   return i;    
   } 
   } </code></pre>
   <p>
 So, any changes to the class A can be handled in B and those changes will not affect the classes using B. Here B can suppress all those changes at its level, so that those do not propagate to other classes</p>
<li>Testability of the code will be easy when we go for composition instead of using inheritance<li>
<p>If my Bus wants to use the Engine class I have two options one is inheritance and other one is composition. But inheritance makes my code difficult to test let's try how? </p>
<img src="../images/one3.jpg" width="100%" height="200px">
<p>For example in the above case my Engine is not fully implemented, only the methods are declared, still the logic has to be written. But meanwhile the other developer as he knows the methods of the Engine he has written the logic for Bus.<br><br> 
 
Now to test class Bus I need the Engine, so to facilitate the testing I need to create dummy class for Engine, using which I can test my drive method of the Bus as shown below.</p>
<pre ><code class="language-java"> // dummy class or prototype class for the actual engine 
class PrototypeEngine1 {   
 public boolean start() {       
 // do something.       
 return true;    
 } 
 } </code></pre>
 <p>Now I need to modify the Bus class to extend it from PrototypeEngine1 to test it as shown below.</p>
 <pre ><code class="language-java">class Bus extends PrototypeEngine1 {  
 public void drive() {       
 boolean isStarted = false;           
 isStarted = super.start();      
 if(isStarted == true) {        
 // do something      
 }
 else {        
 // do something     
 }   
 } 
 } </code></pre>
 <p>But just testing against one Dummy or Prototype class I cannot certify my Bus is working, rather I should be able to test it against lot of prototype engines in this way. So always I need to keep on changing the class from which I need to extend from.</p>
 <table>
  <th></th>
  <th></th>
  <tr>
    <td><pre ><code class="language-java">class Bus extends PrototypeEngine2 {    
	public void drive() {      
	boolean isStarted = false;           
	isStarted = super.start();      
	if(isStarted == true) {        
	// do something      
	}
	else {       
	// do something      
	}    
	} 
	}</code></pre>
	</td>
    </tr>
  
  
  <tr>
    <td><pre ><code class="language-java">class Bus extends PrototypeEngine3{    
	public void drive() {      
	boolean isStarted = false;           
	isStarted = super.start();      
	if(isStarted == true) {        
	// do something      
	} 
	else {        
	// do something      
	}    
	} 
	}</code></pre>
	</td>
  </tr>
  </table>
  <p>If you look as inheritance makes a class static reference to another class it makes harder to test my Bus class against different prototypes of Engine and demands code changes to test against different. Instead if I use composition it gives me lot of flexibility as shown below.</p>
  <p>Create multiple prototype Engine classes extending from the abstract class Engine as shown below.</p>
  <img src="../images/two2.jpg" width="100%" height="200px">
      <pre ><code class="language-java">class Bus {    private Engine engine; 
 
   public Bus(Engine engine) {      
   this.engine = engine;    
   } 
   public void drive() {     
   boolean isStarted = false;              
   isStarted = engine.start();       
   if(isStarted == true) {        
   // do something       
   } 
   else {         
   // do something.      
   }    
   } 
   } </code></pre>
   <p>Now in my test class while testing the Bus pass different prototype Engines as input which makes your object to point to different Engines without modifying the code as shown below. </p>
       <pre ><code class="language-java">class TestBus {    
	   public void testDrive() {       
	   new Bus(new PrototypeEngine1()).drive();       
	   new Bus(new PrototypeEngine2()).drive();   
	   } 
	   } </code></pre>
     <p>Now I can test Bus without modifying the code by making it point to several references of EnginePrototype which makes my code easily test. </p>
	 <p>So let’s try to understand how to use inheritance by taking an example.</p>
	 <img src="../images/two3.jpg" width="100%" height="200px">
	 <p>In the above diagram I have a vehicle which contain drive (), fly () and blow horn (honk ()). So I want to represent a Car and a Flight which is of Vehicle type. If I try to express this with Inheritance I will end up in implementing fly method in Car class as empty and drive method in flight class as empty (because the fly and drive are in-appropriate for Car and Flight respectively).<br><br> 
 
So to overcome this modifies your class structure into two hierarchies as Drivable and Flyable making Vehicle as sub-classes shown below. </p>
<img src="../images/two4.jpg" width="100%" height="200px">
<p>But the problem with above approach is your design model is rigid (closed). Through the above design you are stating you can have a vehicle which can either fly or drive. But in future if I have a vehicle which can drive as well as fly then it is not possible to represent that kind of vehicle with the above design. This may leads to re-designing the entire application. </p>
<p>So, by the above example it is clear that we can’t represent all the problems through inheritance. In order to solve this, Composition would be more apt than Inheritance. Below diagram shows the solution for the above described problem</p>
<img src="../images/two5.jpg" width="100%" height="200px">
<p>In the above diagram Vehicle is an abstract class. We created two more concrete classes Drivable and Flyable which contains logic for drive () and fly () respectively. As every vehicle may contain drive() or fly() or both, we declared both these classes as attributes inside Vehicle class.<br><br> 
 
Now class Car & Flight extends from vehicle. Let's say in the class Car we have the method drive() it will calls the drive() method on the super class attribute drivable as shown below.</p>
<table>
  
  <tr>
    <td>    <pre ><code class="language-java">class Car extends Vehicle {    
	public Car() {       
	setDrivable(new Drivable());    
	}     
	public void drive() {        
	drivable.drive();      
	} 
	}</code></pre>
</td>
    <td>    <pre ><code class="language-java">class Flight extends Vehicle {   
	public Flight() {     
	setFlyable(new Flyable());   
	}   
	public void fly() {       
	flyable.fly();    
	} 
	}  </code></pre>
</td>
  </tr>
  </table>
  <p>In the same way Flight is another class extends from Vehicle and it only sets the flyable object reference and calls the fly() method to use the functionality. Tomorrow if we have a vehicle which can drive() and can fly() then in my class we need to set the references of both Drivable and Flyable and can use it.<br><br> 
 
Using composition now we have a flexibility of having both fly() and drive() as part of our sub-classes, this cannot be achieved by inheritance. </p>
  <p  style="font-weight:bold;color:#212121">Always design to interfaces, never code to implementation</p>
  <p>In our earlier discussion we understood most of the times we should prefer to use Composition rather than inheritance. Yes, but when we use composition, the coupling between the classes will be high.<br><br> 
 
For e.g When Vehicle is referring to Drivable or Flyable it means without the presence of Drivable and Flyable class Vehicle cannot be complete. Let's say we have a new car came which uses an Automatic Drive technic rather than normal one or a new Flight which needs to by fly with new technic. It cannot be changed as Vehicle holds the concrete references of Drivable and Flyable classes we cannot change it.<br><br> 
 
Now let's declare two interfaces IDrivable contains drive() and IFlyable contains fly() method. Declare these two interfaces as attributes in Vehicle class. Now create DefaultDrivable and DefaultFlyable as implementations of those interfaces.<br><br> 
 
As Vechicle holds the interface reference type we can set those to object of its implementation to those references. In future we need new drive() technic, we can create one more implementation of IDrivable interface and can plug-in. Here is the below diagram depicting the same</p>
<img src="../images/two6.jpg" width="100%" height="200px">
  <p  style="font-weight:bold;color:#212121">Code should be open for extension and should be closed for modification</p>
  <p>Let's say a new car came, and it uses a different drive technic, now we don’t need to modify the DefaultDrivable class rather we can create one more implementation of the IDrivable interface and can set it as a reference to drivable reference. If we modify the existing code the chances of increasing the bugs would be more, rather than our design should be flexible enough to plug-in new implementations when required, our earlier design depicts the same. </p>
  <div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Spring Inversion of Control (IOC)</span></div>
  <p>Let's try to understand the IOC by taking one example, first let us design our classes by following strategy design pattern, and then we will identify the pit-falls in it and will understand how to simplify it using IOC 
We have a MessageWriter class which will write the message to the console. The MessageWriter class will get the message from MessageProducer class. But we have multiple types of MessageProducers like TextMessageProducer, HTMLMessageProducer etc. 
So the MessageWriter will talks to the message producers through an interface IMessageProducer, which defines a method formatMessage. This has been explained in the below diagram. </p>
<img src="../images/two7.jpg" width="100%" height="200px">
<p>If you observe carefully the above design has followed all the design principles that spring recommends. Code fragment for the above classes are as shown below</p>
  <p  style="font-weight:bold;color:#212121">IMessageProducer.java</p>
      <pre ><code class="language-java">package com.ioc.beans; 
	  public interface IMessageProducer {  
	  String formatMessage(String message); 
	  } </code></pre>
	    <p  style="font-weight:bold;color:#212121">TextMessageProducer.java </p>
		    <pre ><code class="language-java"> package com.ioc.beans; 
 
public class TextMessageProducer implements IMessageProducer {       
public String formatMessage(String message) {           
return "Hello " + message + "!";       
} 
} </code></pre>

  <p  style="font-weight:bold;color:#212121">HTMLMessageProducer.java</p>
      <pre ><code class="language-java"> package com.ioc.beans; 
 
public class HTMLMessageProducer implements IMessageProducer {     
public String formatMessage(String message) {         
return "<HTML><HEAD></HEAD><BODY>" + message + "</BODY></HTML>";     
} 
}</code></pre>

    <p  style="font-weight:bold;color:#212121">MessageWriter.java </p>
    <pre ><code class="language-java"> package com.ioc.beans; 
public class MessageWriter {    
private IMessageProducer messageProducer;    
public void writeMessage(String message) {        
// instantiate messageProducer with concrete implementation class        
messageProducer = new HTMLMessageProducer();        
String formattedData = messageProducer.formatMessage(message);        
System.out.println(formattedData);    
} 
}</code></pre>
  <p  style="font-weight:bold;color:#212121">MessageTest.java</p>
      <pre ><code class="language-java"> package com.ioc.beans; 
public class MessageTest {    
 public static void main(String args[]) {        
 MessageWriter writer = new MessageWriter();         
 writer.writeMessage("Welcome to Spring");    
 } 
 } </code></pre>
<p>Even you followed the recommended design principles, it has two problems.</p>
<li>In your MessageWriter class inside the writeMessage method you have hardcoded the concrete class name HTMLMessageProducer while instantiating messageProducer attribute. If you want to switch between HTMLMessageProducer to TextMessageProducer you need to modify the source code of the MessageWriter. </li>
<li>MessageWriter to use the services of HTMLMessageProducer it is trying to create the object of it.If MessageWriter is trying to create the Object of HTMLMessageProducer or TextMessageProducer, it has to know the complete instantiation process of creating those. Some classes can be created out of calling new Operator, but some classes should be created using complex instantiation technic like sometimes let's say 'A' want 'B' it has to create 'B' but to create 'B' it is using 'C' so first create 'C' and then 'B' finally 'A' can use it.</li>
<p>This tells unless 'A' instantiates all the dependents that 'B' needs it cannot use, and the same piece of code has to be written by all the other classes which ever want to use 'B'. So, code is duplicated across the logic to create 'B'<br><br> 
To avoid the above problems instead of MessageWriter creating the Object of IMessageProducer implementation class, it should externalize this functionality to someone else, that's where factory classes come into picture.<br><br> 
In Jdbc Connection is an interface & Database vendors will have the implementation, if I want to switch between Oracle DB to MySql Database, I don't need to modify the code because my classes are talking to the interfaces, there are not talking to create implementations.<br><br> 
But in-order to create Connection I can't create the Connection as</p>
    <pre ><code class="language-java"> Connection con = new Connection()</code></pre>
	<p>Because Connection is an interface, to instantiate it we need implementation of it. We don’t know what is the implementation of Connection to instantiate? That's where DriverManager (factory) will find the implementation class and instantiate it.<br><br> 
 
So, here DriverManager acts as a factory for creating the object of Connection interface. Factories are the classes who will manufacture the objects of other classes. They hide the complexity in creating the objects of other classes.<br><br> 
 
Let's say I want a Car, but to drive a Car I don't need to know how to create a Car rather I just need to go to a Car factory, factory will create a car and gives to us.<br><br> 
 
Similarly if we want IMessageProducer Implementation, we can create MessageProducerFactory which will have a factory method, it creates the Object of one of the implementation of IMessageProducer and returns to use as shown below.</p>
    <pre ><code class="language-java"> public class MessageProducerFactory {     
	public static IMessageProducer createMessageProducer(String type) {         
	if(type.equals("html")) {           
	return new HTMLMessageProducer();         
	}
	else if(type.equals("text")){            
	return new TextMessageProducer();         
	}        
	return null;     
	} 
	} </code></pre>
	<p>In the above class I have a factory method called createMessageProducer upon calling will create the one of the implementation of IMessageProducer and returns to us based on the 'type' we passed as input.<br><br> 
 
With the above we are able to avoid the two problems we discussed earlier, now we don’t need to refer to the concreate class name of other class and we don’t need to know the complex instantiation process of creating the object of other classes. The modified code for MessageWriter shown below.</p>
  <p  style="font-weight:bold;color:#212121">Modified#1 - MessageWriter.java </p>
      <pre ><code class="language-java">package com.ioc.beans; 
public class MessageWriter {   
 private IMessageProducer messageProducer;   
 public void writeMessage(String message) {       
 messageProducer = MessageProducerFactory.createMessageProducer("html");        
 String formattedData = messageProducer.formatMessage(message);        
 System.out.println(formattedData);    
 } 
 } </code></pre>
 <p>If we look at the above code, even we are able to avoid the concreate class name of other class still we are referring to the logical name of other class as 'html' or 'text' again there is a level of coupling.<br><br> 
 
By this we understood when we create the object of other class or when we try to get (pull) the object of other class through some factory, our classes will be tightly coupled to other classes. To avoid this, my class should not have the code for creating or pulling rather the dependent object need to be injected.<br><br> 
 
To inject we need to create a setter or constructor around the dependent attribute of our class. So, whoever wants to use MessageWriter will set the dependent and call the method?<br><br> 
 
Below is the modified version of MessageWriter for the same. Here test class is setting IMessageProducer implementation and calling the method writeMessage()</p>
  <p  style="font-weight:bold;color:#212121">Modified#2 - MessageWriter.java</p>
      <pre ><code class="language-java">package com.ioc.beans; 
public class MessageWriter {    
private IMessageProducer messageProducer;   
 public void writeMessage(String message) {       
 String formattedData = messageProducer.formatMessage(message);        
 System.out.println(formattedData);   
 } 
 public void setMessageProducer(IMessageProducer messageProducer){      
 this.messageProducer = messageProducer;   
 } 
 }</code></pre>
  <p  style="font-weight:bold;color:#212121">Modified#1 – MessageTest.java</p>
    <pre ><code class="language-java">package com.ioc.beans; 
public class MessageTest {     
public static void main(String args[]) {        
 MessageWriter writer = new MessageWriter();        
 IMessageProducer messageProducer = new HTMLMessageProducer();        
 writer.setMessageProducer(messageProducer);        
 writer.writeMessage("Welcome to Spring");     
 } 
 }</code></pre>
 <p>If you see the MessageWriter class it is loosely coupled from HTMLMessageProducer and now it can talk to any IMessageProducer implementation classes. Second thing MessageWriter doesn’t need to bother about how to instantiate IMessageProducer implementation class, because IMessageProducer implementation class will be injected by calling setter method on it.<br><br>  
 
Even though we made our business class loosely coupled from specific implementation, but still we hardcoded the HTMLMessageProducer in MessageTest class. If you want to use TextMessageProducer instead of HTMLMessageProducer your main method should be modified to instantiate TextMessageProducer class and should pass it to the MessageWriter via calling its setter.<br><br>  
 
So, at some place in your code you are hard coding the concrete class references, in order to avoid this you need to use the Spring IOC. </p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Types of IOC</span></div>
<p>IOC is a principle, IOC means collaborating objects and managing the lifecycle of it. There are two ways using which we can collaborate objects<br><br> 
IOC is of two types; again each type is classified into two more types as follows</p>
<ol>
<li>Dependency Lookup</li>
</ol>
<li>Dependency Pull</li>
<li>Contextual Dependency lookup</li>
<ol>
<li> Dependency Injection </li>
</ol>
<li>Setter Injection </li>
<li>Constructor Injection</li>
  <p  style="font-weight:bold;color:#212121">Dependency Lookup</p>
  <p>Dependency lookup is a very old technic which is something exists already and most of the J2EE applications use. In this technic if a class needs another dependent object; it will write the code for getting the dependency. Again this has two variants as said above</p>
  <ol>
  <li>Dependency Pull</li>
  </ol>
  <p>If we take a J2EE Web application as example, we retrieve and store data from database for displaying the web pages. So, to display data your code requires connection object as dependent, generally the connection object will be retrieved from a Connection Pool.  Connection Pools are created and managed on an Application Server. Below figure shows the same.</p>
  <img src="../images/two8.jpg" width="100%" height="200px">
<p>Your component will look up for the connection from the pool by performing a JNDI lookup. Which means you are writing the code for getting the connection indirectly you are pulling the connection from the pool. So, it is called dependency pull.</p>
  <p  style="font-weight:bold;color:#212121">Pseudo code </p>
      <pre ><code class="language-java"> Context ctx = new InitialContext(); 
	  DataSource ds = ctx.lookup("jndi name of cp"); 
	  Connection con = ds.getConnection() 
	  // pulling the connection</code></pre>
	  <ol>
	  <li>Contextual Dependency Lookup</li>
	  </ol>
	  <p>In this technic your component and your environment/server will agree upon a contract/context, through which the dependent object will be injected into your code.<br><br> 
For e.g If you see a Servlet API, if your servlet has to access environment specific information (init params or to get context) it needs ServletConfig object. But the ServletContainer will create the ServletConfig object. So in order access ServletConfig object in your servlet, you servlet has to implement Servlet interface and override init(ServletConfig) as parameter. Refer the below figure. </p>
<img src="../images/two9.jpg" width="100%" height="200px">
<p>Then the container will pushes the config object by calling the init method of the servlet. Until your code implements from servlet interface, container will not pushes the config object, this indicates servlet interface acts as a contract between you and your servlet so, and it is called Context Dependency Lookup (CDL).</p>
  <p  style="font-weight:bold;color:#212121">Dependency Injection</p>
  <p>Even though spring supports the above mentioned two technics, the new way of acquiring the dependent objects is using setter injection or constructor injection. This is detailed as below.</p>
  <ol>
  <li>Setter Injection</li>
  </ol>
  <p>In setter injection if an object depends on another object then the dependent object will be injected into the target class through the setter method that has been exposed on the target classes as shown below.</p>
 <img src="../images/two10.jpg" width="100%" height="250px">
 <p>In the above diagram MessageWriter is the target class onto which the dependent object IMessageProducer implementation will be injected by calling the exposed setter method</p>
 <ol>
 <li>Constructor Injection</li>
 </ol>
 <p>In this technic instead of exposing a setter, your target class will expose a constructor, which will take the parameter of your dependent object. As your dependent object gets injected by calling the target class constructor, hence it is called constructor injection as shown below.</p>
 <img src="../images/two11.jpg" width="100%" height="200px">
 <p>Let's modify the earlier example to inject the IMessageProducer into MessageWriter through setter injection and constructor injection.<br><br> 
 
If we want our class objects to be managed by spring then we should declare our classes as spring beans, any object that is managed by spring is called spring bean. Here the term manages refers to Object creation and Dependency injection (via setter, constructor etc...).<br><br> 
 
So in our example we want MessageWriter and IMessageProducer implementation classes to be created and injected by spring, so we need to declare them spring in a configuration file called "Spring Beans configuration".</p>
<p>"Spring Bean configuration" is an xml file in which we declare all the classes as beans, so that those will be managed by spring. We need to use bean tag to declare a class as spring bean. The below fragment shows how to create a class as spring bean</p>
  <p  style="font-weight:bold;color:#212121">Spring Beans Configuration (application-context.xml)</p>
      <pre ><code class="language-java"> <?xml version="1.0" encoding="UTF-8"?> 
	  <beans xmlns="http://www.springframework.org/schema/beans" 
	  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> 
	  <bean id="textMessageProducer" class="com.ioc.beans.TextMessageProducer" />   
	  <bean id="htmlMessageProducer" class="com.ioc.beans.HTMLMessageProducer" />   
	  <bean id="messageWriter" class="com.ioc.beans.MessageWriter"/> </beans></code></pre>
	  <p>The org.springframework.beans and org.springframework.context packages are the basis for the Spring Framework’s IOC Container. By just declaring our classes as beans in the spring bean configuration files automatically objects will not be created, rather we need to give this configuration as input to BeanFactory. The BeanFactory is an interface and the implementations of it know reading the configuration file and instantiating the beans.<br><br> 
We can declare the information about our classes in multiple ways for e.g. in properties file or xml or annotations. Based on the style of configuration we need to use one of the implementations of BeanFactory interface. Here we are using xml for configuring our class information, so we should use XMLBeanFactory implementation.</p>
  <p  style="font-weight:bold;color:#212121">Creating IOC Container</p>
      <pre ><code class="language-java"> BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
	  "com/injection/common/application-context.xml"));</code></pre>
	  <p>Now to get the bean from the spring, we need to call the method factory.getBean("beanId"). Here beanId refers to the id with which we configured it in spring bean configuration.<br><br> 
Below is the code fragment explaining how to use the beans or objects created by spring. </p>
    <pre ><code class="language-java"> package com.injection.test; 
 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.ioc.beans.MessageWriter; 
 
public class MessageWriterTest { 
 public static void main(String[] args) {  
 BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
 "com/ioc/common/application-context.xml"));  
 MessageWriter messageWriter = factory.getBean("messageWriter",MessageWriter.class);                   
 // now get message producer and set it to message writer                   
 IMessageProducer messageProducer = factory.getBean(“htmlMessageProducer”, IMessageProducer.class);                  
 messageWriter.setMessageProducer(messageProducer);   
 messageWriter.writeMessage("Welcome to Spring");  
 } 
 } </code></pre>
 <p>In the above example we are not creating the beans rather spring itself has created the objects for our classes we are just getting those objects from Spring. After getting MessageWriter and HTMLMessageProducer, we are explicitly calling the setMessageProducer(..) method to inject messageProducer into MessageWriter class, because in our declaration (spring bean configuration file) we just asked spring to create the objects of our classes, we never asked him to manage the dependencies.<br><br> 
As both the objects created by spring, we got them and calling setter to inject one into another, so if I don’t want to use HTMLMessageProducer instead I want to use TextMessageProducer, again I need to modify the code why? Because we are managing the depencdencies. So I should not create or should not pull rather pass the object of dependent HTMLMessageProducer to Target MessageWriter using spring.<br><br> 
Will spring does? Yes, as both the objects are created by spring, we can request spring to help us in calling a setter method or constructior other guy by passing HTMLMessageProducer or TextMessageProducer. How? Only way of talking to spring is through spring bean configuration file.<br><br> 
Instead of us injecting we want spring to create these objects and inject one into another, in order to do this we need to declare all the classes in configuration file including their dependency relations.</p>
  <p  style="font-weight:bold;color:#212121">Spring Beans configuration File (application-context.xml)</p>
      <pre ><code class="language-java"><?xml version="1.0" encoding="UTF-8"?> 
	  <beans xmlns="http://www.springframework.org/schema/beans"  
	  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> 
	  <bean id="textMessageProducer"  class="com.ioc.beans.TextMessageProducer" /> 
	  <bean id="htmlMessageProducer"  class="com.ioc.beans.HTMLMessageProducer" />  
	  <bean id="messageWriter" class="com.ioc.beans.MessageWriter">   
	  <property name=”messageProducer” ref=”htmlMessageProducer”/>  </bean> </beans> </code></pre>
	  <p>In order to inject htmlMessageProducer bean into messageWriter bean we need to declare the <property> tag. The name attribute of it refers to the target class attribute. Ref attribute refers to which bean has to be injected into name attribute (by calling its setter's). 
<property> tag is used for performing setter injection and the dependent object will be injected into target class by callings the setter in target</p>
  <p  style="font-weight:bold;color:#212121">MessageTest.java</p>
      <pre ><code class="language-java">
 package com.injection.test; 
 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.ioc.beans.MessageWriter; 
 
public class MessageWriterTest {  
public static void main(String[] args) {  
 BeanFactory factory = new XmlBeanFactory(new ClassPathResource(    
 "com/ioc/common/application-context.xml"));  
 MessageWriter messageWriter = factory.getBean("messageWriter", MessageWriter.class);   
 messageWriter.writeMessage("Welcome to Spring"); 
 } 
 } </code></pre>
<p>Now in the above code we are not calling the setter rather when we get the MessageWriter from spring it will be created by injecting the HTMLMessageProducer into it by spring. If I want to change from HTMLMessageProducer to TextMessageProducer, we can simply change the reference of it in spring bean</p>
<p>configuration file so, that I can switch between various dependencies. So my classes are completely loosely coupled.<br><br> 
Another way of managing the dependencies is using constructor, below example shows how to inject IMessageProducer into MessageWriter using constructor injection.<br><br>  
In order to perform constructor injection, your target class MessageWriter instead of exposing a setter, should expose a constructor which should take IMessageProducer as parameter.<br><br>  
Along with this need to modify the “Spring beans configuration” to instruct to inject by calling constructor using <constructor-arg> tag rather than setter injection.<br><br>  
Below code fragment shows how to implement the same. </p>
  <p  style="font-weight:bold;color:#212121">Modified#2 - MessageWriter.java </p>
      <pre ><code class="language-java">package com.ioc.beans; 
public class MessageWriter {   
 private IMessageProducer messageProducer; 
 // constructor taking IMessageProducer parameter   
 public MessageWriter(IMessageProducer messageProducer) {       
 this.messageProducer = messageProducer;   
 } 
 public void writeMessage(String message) {       
 String formattedData = messageProducer.formatMessage(message);      
 System.out.println(formattedData);    
 } 
 } </code></pre>
   <p  style="font-weight:bold;color:#212121">Spring Beans configuration File (application-context.xml)
       <pre ><code class="language-java"><?xml version="1.0" encoding="UTF-8"?> 
	   <beans xmlns="http://www.springframework.org/schema/beans"  
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	   xsi:schemaLocation="http://www.springframework.org/schema/beans 
	   http://www.springframework.org/schema/beans/spring-beans.xsd"> 
	   <bean id="textMessageProducer"  class="com.ioc.beans.TextMessageProducer" /> 
	   <bean id="htmlMessageProducer"  class="com.ioc.beans.HTMLMessageProducer" />  
	   <bean id="messageWriter" class="com.ioc.beans.MessageWriter">   
	   <constructor-arg ref=”htmlMessageProducer”/>  
	   </bean> </beans></code></pre></p>
<p>If you observe the above examples it’s clearly evident that our application components are loosely coupled and instead of we creating the objects and managing the dependencies, spring is doing this for us. So, as we specify the things in configuration it is easy to maintain and modify without touching the source of our application.<br><br> 
Below diagram shows the IOC process through Setter or Constructor injection</p>
<img src="../images/two12.jpg" width="100%" height="200px">
<li>What will happen when we try to create the BeanFactory?</li>
    <pre ><code class="language-java">BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
	"com/injection/common/application-context.xml")) </code></pre>
	<p>When we create a BeanFactory object, ClassPathResource will look for the application-context.xml under the class path of our project and loads and gives it as an input XmlBeanFactory. The XmlBeanFactory will take that Xml and performs well-formness and validity, once that Xml is well-formed and valid; it will place the Xml into the Jvm memory. This location where the spring bean objects and its metadata is places is called core container or ioc container. IOC Container is just a logical memory partition in which our spring beans will be maintained (it is similar to hashmap data structure).<br><br> 
The xml will be placed as in-memory metadata in the IOC container and gives the reference of BeanFactory object to us. When we call factory.getBean("messageWriter"), then the BeanFactory goes into its in-memory metadata of the IOC container search for the bean reference with that id. If found it will creates the object of the class by calling new operator and places the object in the IOC container with the given id and returns the reference of it.<br><br> 
So, all the beans we declared in spring bean configuration file are created and managed in the IOC Container in spring.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Constructor VS Setter Injection</span></div>
<p>As said above we have two types of Dependency Injection’s, constructor injection and setter injection. Here are the points that make us understand when to use constructor inject and setter injection. </p>
<table><tr>
  <th>  <p  style="font-weight:bold;color:#212121">Constructor Injection</p>
</th>
  <th>  <p  style="font-weight:bold;color:#212121">Setter Injection </p>
</th></tr>
  <tr>
    <td>
	<li>At the time of creating your target class object, the dependent objects are injected (can be accessed in the constructor of target class).</li>
    <li>In case of constructor injection all the dependent objects are mandatory to be injected. If you don’t provide any of the dependent objects through <contructor-arg> tag the core container will detects and throws BeanCreationException</li>
    <li>If classes have cyclic dependencies via constructor, these dependent beans cannot be configured through Constructor Injection</li>
    <td>
	<li>The dependent objects are not injected while creating the target classes object. Those will be injected after the target class has been instantiated, by calling the setter on the target object. </li>
    <li>In case of setter injection your dependent objects are optional to be injected. Even you don’t provide the <property> tag while declaring the bean; the container will creates the Bean and initializes all the properties to their default</li>
    <li>Cyclic dependencies are allowed in Setter Injection.</li>
	</td>
  </tr>
  </table>
  <div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Resolving/Mapping Constructor Arguments </span></div>
<p>Even we pass the required amount of parameters in calling a constructor spring will not be able to determine the correct constructor for the arguments we passed and result in an error or in-correct mapping. This means spring will be confused sometimes in calling a constructor.</p>
<p>We can solve this confusion in three ways:</p>
<ol>
<li>Using type attribute</li>
<li>Using index attribute</li>
<li>Using name attribute</li>
</ol>
<p>Let’s consider a case where spring cannot resolve the constructor arguments directly.</p>
  <p  style="font-weight:bold;color:#212121">Using type attribute </p>
  <p><b>Robot.java</b></p>
      <pre ><code class="language-java"> package com.cc.beans; 
 
 public class Robot {  
 private int id; 
 private String name;  
 private String type; 
 public Robot(String name, String type) {  
 this.type = type;   this.name = name; 
 } 
 public Robot(int id, String type) {   
 this.id = id;   this.type = type; 
 } 
 @Override  public String toString() {  
 return "Robot [id=" + id + ", name=" + name + ", type=" + type + "]";  
 } 
 
}</code></pre>
<p>In the above example the Robot class has two constructors one will take (String, String) and another takes (int, String) as parameter, if you configure this class as spring bean, you need to pass the argument one of these constructors. Let's say we are passing the values to the constructor as below </p>
  <p  style="font-weight:bold;color:#212121">application-context.xml </p>
    <pre ><code class="language-java"> <?xml version="1.0" encoding="UTF-8"?> 
	<beans xmlns="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd"> 
    <bean id="robot" class="com.cc.beans.Robot">   
    <constructor-arg value="10"/>   
    <constructor-arg value="Robot"/> </bean> </beans> </code></pre>
<p>Guess with the above bean definition which constructor will be called on our class? It will call (String, String) argument constructor, because by default any value that you configured in the spring bean configuration file will be treated as String, so even you pass “10” integer value spring will confuse and treats it as String rather than integer and invokes the two String argument constructor. To resolve this we need to use type attribute at the bean tag level as shown below</p>
  <p  style="font-weight:bold;color:#212121">Modified #1 - application-context.xml</p>
    <pre ><code class="language-java"> &lt?xml version="1.0" encoding="UTF-8"?&gt 
	&ltbeans xmlns="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd"&gt 
 &ltbean id="robot" class="com.cc.beans.Robot"&gt   
 &ltconstructor-arg value="10" type="int"/&gt 
 &ltconstructor-arg value="Robot"/&gt  &lt/bean&gt &ltbeans </code></pre>
<p>In the above configuration we are telling the value we are passing is of type "integer" and we are asking the spring to map it to an appropriate constructor as per it</p>
  <p  style="font-weight:bold;color:#212121">Using index attribute</p>
  <p>Let us consider one more scenario where the same robot class contains one constructor as (int, String) as shown below. </p>
    <p  style="font-weight:bold;color:#212121">Modified - #2 Robot.java </p>

      <pre ><code class="language-java"> package com.cc.beans; 
 
public class Robot { 
 private int id; 
 private String name; 
 private String type; 
 public Robot(int id, String name) {  
 this.id = id;   this.name = name; 
 } 
 
 @Override  public String toString() {  
 return "Robot [id=" + id + ", name=" + name + ", type=" + type + "]"; 
 } 
 }</code></pre>
 <p>If you try to configure this as spring bean, you need to configure the values in the same order of argument declaration. In case if the order mis-match then it will not be able to detect the relevant constructor. To resolve this you need to use index. Index lets you point the argument declaration to method parameters irrespective of the order in which those has been declared in configuration as shown below.</p>
  <p  style="font-weight:bold;color:#212121">Modified - #2 application-context.xml</p>
      <pre ><code class="language-java"> &lt?xml version="1.0" encoding="UTF-8"?&gt 
	  &ltbeans xmlns="http://www.springframework.org/schema/beans"  
	  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	  xsi:schemaLocation="http://www.springframework.org/schema/beans 
	  http://www.springframework.org/schema/beans/spring-beans.xsd"&gt   
	  &ltbean id="robot" class="com.cc.beans.Robot"&gt  
	  &ltconstructor-arg value="adf2" index="1"/&gt   
	  &ltconstructor-arg value="10"/&lt  &lt/bean&gt  &lt/beans&gt </code></pre>
	  <p>When we use index, if there are n parameters for the constructor we need to specify the index value for n-1 parameters only<p>
	    <p  style="font-weight:bold;color:#212121">Using name attribute</p>
		<p>Instead of using index, the other way of mapping the parameters to the arguments of the constructor is using name attribute at the bean tag level, show as below</p>
    <pre ><code class="language-java"> package com.cc.beans; 
	import java.beans.ConstructorProperties; 
	public class Robot {  
	private int id;  
	private String name;  
	private String type;  
	@ConstructorProperties({ "id", "name" })  
	public Robot(int id, String name) {   
	this.id = id;   this.name = name;  
	}  
	@Override  public String toString() {   
	return "Robot [id=" + id + ", name=" + name + ", type=" + type + "]";  
	} 
	}</code></pre>
	<p>
 To use a name attribute at spring bean level to map the parameters, either we need to compile the code with –debug flag or we need to annotate our constructor with @ConstructorProperties as shown above.</p>
    <pre ><code class="language-java"> &lt?xml version="1.0" encoding="UTF-8"?> 
	&ltbeans xmlns="http://www.springframework.org/schema/beans"  
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans.xsd"> 
 &ltbean id="robot" class="com.cc.beans.Robot">  
 &ltconstructor-arg name="name" value="Andriod" />   
 &ltconstructor-arg name="id" value="10" />  &lt/bean> &lt/beans></code></pre>
<p>Run the above program you should see the output as expected. </p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Collection Dependency Injection</span></div>
<p>Spring not only supports inject primitives and objects to be injected as dependents into target classes, along with that spring even supports injected collections as dependent objects into the target class.<br><br> 
In spring you can inject four types of collections as dependent objects into your target classes.  Those are List, Set, Map and Properties. Spring has provided convenient tags that allow you to create these objects in declarations and allow you to inject into your target classes.</p>
<ol>
<li>Injecting List </li>
</ol>
    <pre ><code class="language-java"> package com.cdi.beans; 
 import java.util.List;
 import java.util.Properties; 
 import java.util.Set; 
 public class Course { 
 private List<String> subjects; 
 public void setSubjects(List<String> subjects) {  
 this.subjects = subjects; 
  } 
  // toString();
  }</code></pre>
  <p>In the above Course class we have List of subjects, while configuring the course class as a spring bean, we want to inject subjects list as well. In order to inject the list we need to use a <list> tag or <util:list> tag. Either using <list> or <util:list> has the same behavior, "util" namespace has been introduced from spring 2.0. The idea behind having the "util" namespace separately is to have namespace compartmentalization.<br><> Below code snippet shows the configuration for injecting list. </p>
  <p  style="font-weight:bold;color:#212121">application-context.xml </p>
      <pre ><code class="language-java">
	  &ltbean id="bTechCS" class="com.cdi.beans.Course"&gt  
	  &ltproperty name="subjects"&gt 
	  &ltlist value-type="java.lang.String&gt    
	  <value>C</value>    
	  <value>C++</value>   
	  <value>Java</value>   </list>  </property> </bean> </code></pre>
	  <ol>
<li>Injecting Set</li>
</ol>
As you know the difference between list and set, list allows duplicates whereas set doesn't allow duplicates. You can inject set as dependent object using the tag &ltset&gt. Set has set of values, so the &ltset&gt tag contains &ltvalue&gt as child element, the same has been demonstrated in the below code
  <p  style="font-weight:bold;color:#212121">Course.java</p>
    <pre ><code class="language-java">package com.cdi.beans; 
 import java.util.Set; 
 public class Course {  
 private Set<String> faculties;  
  public Course(Set<String> faculties) {   
  this.faculties = faculties;  
  } 
 public void showFaculties() {  
 System.out.println("Faculties :");  
 for (String f : faculties) {    
 System.out.println(f);   
 } 
 } 
 }</code></pre>
   <p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">
&ltbean id="bTechCS" class="com.cdi.beans.Course"&gt  
&ltconstructor-arg&gt   
&ltset value-type="java.lang.String"&gt    
&ltvalue>Mark&lt/value&gt    
&ltvalue>John&lt/value&gt   &lt/set&gt  &lt/constructor-arg&gt &lt/bean&gt </code></pre>
<ol>
<li>Injecting Map</li>
</ol>
<p>Map is a collection which contains key and value pair. In case of Map the key can be any type and value can be any type. In order to create a map and inject into target class you need to use &ltmap&gt tag. As map contains key and values the sub elements under it is &ltentry key=""&gt&ltvalue&gt&lt/entry&gt tag. The below snippet shows the same</p>
  <p  style="font-weight:bold;color:#212121">University.java </p>
      <pre ><code class="language-java">package com.cdi.beans; 
 import java.util.Map; 
 public class University {  
 private Map<String, Course> facultyCourseMap; 
 public void setFacultyCourseMap(Map<String, Course> facultyCourseMap) {   
 this.facultyCourseMap = facultyCourseMap;  
 }    
 public void showUniversityInfo() {   
 System.out.println("University courses : ");   
 for(String f : facultyCourseMap.keySet()) {    
 System.out.println("*****Course Info*****");    
 Course c = facultyCourseMap.get(f);    
 c.showSubjects();    
 c.showFaculties();    
 c.showFacultySubjects();   
 }  
 } </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
<pre ><code class="language-java">&ltbean id="ou" class="com.cdi.beans.University"&gt  
&ltproperty name="facultyCourseMap"&gt   
&ltmap key-type="java.lang.String" value-type="com.cdi.beans.Course"&gt    
&ltentry key="mark"&gt     
&ltref bean="bTechCS"/&gt    
&lt/entry>    
&ltentry key="john" value-ref="mca"/&gt   
&lt/map&gt  
&lt/property&gt 
&lt/bean&gt</code></pre>
<ol>
<li>Injecting Properties</li>
</ol>
<p>Properties is also a Key and Value type collection, but the main difference between Map and Properties is Map can contain key and value as object type, but the Properties has key and value as string only.<br><br> 
 
In order to inject properties as dependent object, you need to use the tag &ltprops&gt, this has sub elements &ltprop key=""&gtvalue here&lt/prop&gt. <br><br> 
 
Refer to the following example for the same</p>
  <p  style="font-weight:bold;color:#212121">Course.java</p>
    <pre ><code class="language-java">package com.cdi.beans; 
 import java.util.Properties; 
 public class Course {  
 private Properties facultySubjects;    
 public void setFacultySubjects(Properties facultySubjects) {   
 this.facultySubjects = facultySubjects;  
 } 
 public void showFacultySubjects() {   
 System.out.println("Faculty --> Subjects");   
 for(Object o : facultySubjects.keySet()) {    
 System.out.print(o + " --> ");    
 System.out.println(facultySubjects.get(o));   
 }  
 } 
 }</code></pre>
   <p  style="font-weight:bold;color:#212121">application-context.xml</p>
   <pre ><code class="language-java">&ltbean id="mca" class="com.cdi.beans.Course"&gt  
&ltproperty name="facultySubjects"&gt   
&ltprops&gt    
&ltprop key="Mark"&gtC&lt/prop&gt    &ltprop key="John"&gtS.E&lt/prop&gt   &lt/props&gt  &lt/property&gt &lt/bean&gt </code></pre>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Using Util:Namespace </span></div>
<p>Following are the problems with above collection injection</p>
<ol>
<li>In the above bean configuration we are configuring the &lt;list&gt or &ltset&gt or &ltmap&gt or &ltprops&gt collection tags inside the &ltproperty&gt or &ltconstructor-arg&gt tag, if we want to reuse the same collection in another bean or property we need to redeclare the collection configuration</li>
<li>By default spring will instantiate the default implementation of a collection interface type for example if we configure the &ltlist&gt tag it creates LinkedList as a default object, if we want to change the implementation collection type it is not possible with default collection tags we used above</li>
</ol>
<p></p>
    <pre ><code class="language-java">&ltbean id="bTechCS" class="com.cdi.beans.Course">  
&ltproperty name="subjects" ref=”courses”/> 
&lt/bean> 
&ltutil:list id=”courses” list-class=”java.util.Vector” value-type="java.lang.String">  
&ltvalue>C&lt/value>  
&ltvalue>C++&lt/value>  
&ltvalue>Java&lt/value> 
&lt/util:list></code></pre>
	<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff"></span></div>
<p>Inheritance is the concept of reusing the existing functionality. In case of java you can inherit a class from an Interface or another class. When you inherit a class from another class, your child or derived class can use all of the functionalities of your base class.<br><br> 
 
A bean in spring is a class configured with some configuration around it using which spring creates the object for it. Bean inheritance is the concept of re-using the configuration property values of one bean inside another bean is called bean inheritance.<br><br> 
 
I have a class and I configured it as a bean with some values that has to be injected while creating. For the same class I want 10 beans of such type, so how many times I need to configure it as bean, with the same configuration changing the bean id I need to configure 10 beans.<br><br> 
 
This makes your configuration bulgier (more) and any change for one of the value of the property need to be changed across all the 10 beans, duplication of configuration results in more maintenance cost.<br><br> 
 
Is there any alternate to copy the values of one bean into another bean rather than redeclaring the entire configuration? That’s where bean inheritance comes into picture.<br><br> 
 
For e.g. we own a car showroom and it has some cars, car is represented as an object of class Car. A showroom contains several cars to represent it we create more than one beans (objects) for each as shown below. </p>
  <p  style="font-weight:bold;color:#212121">Car.java </p>
    <pre ><code class="language-java">package com.bi.beans; 
 public class Car {  
 private int id;  
 private String name;  
 private String engineType;  
 private String engineModel;  
 private String classType; 
 public void setId(int id) {   
 this.id = id;  } 
 public void setName(String name) {   
 this.name = name;  
 } 
 public void setEngineType(String engineType) {   
 this.engineType = engineType;  
 } 
 public void setEngineModel(String engineModel) {   
 this.engineModel = engineModel;  
 } 
 public void setClassType(String classType) {   
 this.classType = classType;  
 } 
 // override to string 
 }</code></pre>
   <p  style="font-weight:bold;color:#212121">application-context.xml</p>
    <pre ><code class="language-java">&ltbean id="swift1" class="com.bi.beans.Car">  
&ltproperty name="id" value="1"/>  
&ltproperty name="name" value="Swift"/>  
&ltproperty name="engineType" value="Disel"/>  
&ltproperty name="engineModel" value="DDIS"/>  
&ltproperty name="classType" value="HatchBack"/>  
&lt/bean> &ltbean id="swift2" class="com.bi.beans.Car">  
&ltproperty name="id" value="2"/>  
&ltproperty name="name" value="Swift"/>  
&ltproperty name="engineType" value="Disel"/>  
&ltproperty name="engineModel" value="DDIS"/>  
&ltproperty name="classType" value="HatchBack"/>  &lt/bean></code></pre>
<p>In this way if we have 10 cars in the showroom we need to declare 10 beans in the spring bean configuration file, but if we closely observe all the beans contains the configuration values as same across. This results out in duplication of configuration.Rather than declaring the values again in all the beans here we can reuse the properties of swift1 in swift2 car.<br><br> 
 Make the swift2 car inherit from swift1 car so that the values of the swift1 car will be copied into swift2 car and we can avoid declaring the properties again as shown below</p>
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
    <pre ><code class="language-java">&ltbean id="swift1" class="com.bi.beans.Car" parent="baseCar">  
&ltproperty name="id" value="1"/>  
&ltproperty name="name" value="Swift"/>  
&ltproperty name="engineType" value="Disel"/>  
&ltproperty name="engineModel" value="DDIS"/>  
&ltproperty name="classType" value="HatchBack"/>  
&lt/bean> 
&ltbean id="swift2" class="com.bi.beans.Car" parent="swift1">  
&ltproperty name="id" value="2"/> &lt/bean> </code></pre>
<p>Now the name, engineType, engineModel and classType property values will be copied from “swift1” car so we avoid duplication of configuration.<br><br> 
 
The bean that is being inherited is called parent bean, the bean that is getting inherited is called child bean of that parent. Always the parent bean property values will be copied to the child beans.<br><br> 
 
In the above example, the "swift2" car id will be different from "swift1" car id as every car has its own id, so "swift2" car has re-declared the value for the id property, it means the child bean property values will always overwrites the parent bean property values.</p>
<p>In the above example if we observe the "swift1" car is an active bean from which other cars are inheriting from. If any changes to "swift1" car will affect all the other cars as well. To avoid this we need to take one common base car which will contains common property values that can be used by all the other classes.</p> 	
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
    <pre ><code class="language-java">&ltbean id="baseCar" class="com.bi.beans.Car">  
&ltproperty name="name" value="Swift"/>  
&ltproperty name="engineType" value="Disel"/>  
&ltproperty name="engineModel" value="DDIS"/>  
&ltproperty name="classType" value="HatchBack"/>  
&lt/bean> 
&ltbean id="swift1" class="com.bi.beans.Car" parent=”baseCar”>  
&ltproperty name="id" value="1"/> 
&lt/bean> 
&ltbean id="swift2" class="com.bi.beans.Car" parent=”baseCar”>  
&ltproperty name="id" value="2"/> 
&lt/bean></code></pre>
<p>Now in the above case as baseCar is a dummy bean that is declared to hold common values that can be reused, we can declare it as abstract bean so that spring will not create object for it rather it uses its configuration for inheritance.</p>
    <pre ><code class="language-java">&ltbean id="baseCar" class="com.bi.beans.Car" abstract=”true”>  
&ltproperty name="name" value="Swift"/>  
&ltproperty name="engineType" value="Disel"/>  
&ltproperty name="engineModel" value="DDIS"/>  
&ltproperty name="classType" value="HatchBack"/>  
&lt/bean>  </code></pre>
<p>Few points to remember:</p>
<ol>
<li>When we use bean inheritance, the parent bean and the child bean class types are not necessary to be same. All the properties of the parent bean must and should be present in child bean only </li>
<li>When we inherit one bean from another bean, only the parent bean property values will be copied into child bean property values but the physical classes will never get extended.</li>
<li>It is recommended to declare one of the beans as abstract bean which contains all the common values that should be inherited to the child. As it is an abstract bean we never modify any property unless it has to be affected to all</li>
<li>When we declare a bean as abstract, the class will not become abstract only the current bean definition will become abstract, which means spring will not create the object of that bean. Any call to factory.getBean("abstractbean") to an abstract bean will results out in an error.</li>
</ol>
    <pre ><code class="language-java">package com.bi.test; 
 import org.springframework.beans.factory.BeanFactory; 
 import org.springframework.beans.factory.xml.XmlBeanFactory; 
 import org.springframework.core.io.ClassPathResource; 
 import com.bi.beans.Car; 
 public class BITest {  
 public static void main(String[] args) {   
 BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
 "com/cc/common/application-context.xml"));   
 Car car = factory.getBean("swift1", Car.class);   
 System.out.println(car);  
 } 
 } </code></pre>
 <p>In the above configuration we declared baseCar as abstract which means spring IOC container will not instantiate the object for the bean declaration. But it acts as a base bean from which its property values will be inherited to child beans.<br><br>  
 Now when we run the above program, the swift1 car will inherit the values of name, engineType, engineModel, classType from baseCar.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Collection Merging</span></div>
<p>Let us try to understand the collection merging by taking one example, we have a class Course and it has list of subjects. And we create multiple beans of this class to represent different courses offered in a college, let's say btechCS1Yr1Sem and btechECE1Yr1Sem as shown below.</p>
  <p  style="font-weight:bold;color:#212121">Course.java</p>
    <pre ><code class="language-java">package com.cm.beans; 
import java.util.List; 
public class Course {  
private List<String> subjects; 
public void setSubjects(List<String> subjects) 
{   
this.subjects = subjects;  
} 
// override toString() method 
}</code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
    <pre ><code class="language-java">&ltbean id="bTechCS1Yr1Sem" class="com.cm.beans.Course">  
&ltproperty name="subjects">   
<list>    
&ltvalue>c&lt/value>    
&ltvalue>DMS&lt/value>   
&lt/list>  
&lt/property> 
&lt/bean> 
&ltbean id="bTechECE1Yr1Sem" class="com.cm.beans.Course">  
&ltproperty name="subjects">   
&ltlist>    
&ltvalue>c&lt/value>    
&ltvalue>DMS&lt/value>    
&ltvalue>S.E&lt/value>   &lt/list>  
&lt/property> 
&lt/bean> </code></pre>
<p>Now if you see the above configuration few subjects are common across different courses even then also we need to re-declare those. Instead of re-declaring them to reuse we can use bean inheritance. So, now inherit the bTechECE1Yr1Sem bean from bTechCS1Yr1Sem bean as shown below.</p>
  <p  style="font-weight:bold;color:#212121">application-context.xml </p>
<pre ><code class="language-java">&ltbean id="bTechCS1Yr1Sem" class="com.cm.beans.Course">  
&ltproperty name="subjects">   
&ltlist>    
&ltvalue>c&lt/value>    
&ltvalue>DMS&lt/value>   
&lt/list>  
&lt/property> &lt/bean> 
&ltbean id="bTechECE1Yr1Sem" class="com.cm.beans.Course" parent=”bTechCS1Yr1Sem”>  
&ltproperty name="subjects">   
&ltlist>    
&ltvalue>S.E&lt/value> &lt/list>  
&lt/property> 
&lt/bean>  </code></pre>
<p>Can you guess how many subjects will be there in bTechECE1Yr1Sem bean, it will have only on that is 'S.E'! why? Always in case of inheritance the parent bean property value will be overwritten by child bean property values, so the 'C' & 'DMS' will be overwritten by 'S.E' value. But we want the bTechECE1Yr1Sem bean to have all the values including 'C' & 'DMS' is it possible? Yes for that you need to use collection merging</p>
<p>If the parent bean property is a collection type, in the child bean if we have a similar property of the same collection type, we can merge the values of parent property collection with the child using collection merging as shown below.</p>
    <pre ><code class="language-java">&ltbean id="bTechECE1Yr1Sem" class="com.cm.beans.Course" parent=”bTechCS1Yr1Sem”>  
&ltproperty name="subjects">   
&ltlist merge="true">    
&ltvalue>S.E&lt/value>   
&lt/list>  
&lt/property> 
&lt/bean> </code></pre>
<p>Now the bTechECE1Yr1Sem subjects will have all the three including the parent one as well as we said "merge=true".</p>
<p>Few points to remember about collection merging:</p>
<ol>
<li>Collection merging always comes into picture in-case of bean inheritance only.</li>
<li>The parent property collection type and child property collection type we are merging should be of same type.</li>
<li>The parent property collection generic type and the child property collection generic type should always be same</li>
</ol>
<p>Here is the code to test the same.</p>
    <pre ><code class="language-java">package com.cm.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.cm.beans.Course; 
public class CMTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/cm/common/application-context.xml"));   
Course course = factory.getBean("bTech1Yr1Sem", Course.class);   
System.out.println(course);  
} 
}</code></pre>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Inner Beans </span></div>
<p>An inner bean is the concept similar to Inner classes in Java. As how you can create a class inside another class, you can inject a bean into another bean by declaring it inline. Below snippet shows the same.</p>
<p  style="font-weight:bold;color:#212121">BiCycle.java</p>
  <pre ><code class="language-java">package com.ib.beans; 
public class BiCycle { 
private Chain chain; 
public void setChain(Chain chain) {   
this.chain = chain;  
}  
// override toString()    
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">Chain.java </p>
  <pre ><code class="language-java">package com.ib.beans; 
public class Chain {  
private String type; 
public String getType() {   
return type;  
} 
public void setType(String type) {   
this.type = type;  
}          
// override toString() 
} </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml</p>
  <pre ><code class="language-java">&ltbean id="biCycle" class="com.ib.beans.BiCycle">  
&ltproperty name="chain"> 
&ltbean class="com.ib.beans.Chain">    
&ltproperty name="type" value="t1"/> 
&lt/bean>  
&lt/property> 
&lt/bean> </code></pre>
  <pre ><code class="language-java">package com.ib.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.ib.beans.BiCycle; 
public class IBTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/ib/common/application-context.xml"));   
BiCycle bc = factory.getBean("biCycle", BiCycle.class);   
System.out.println(bc);  
} 
} </code></pre>
<p>In the above case if you observe Chain cannot be used independently without a BiCycle, so why it should have an independent existence?<br><br> 
 As no one is going to use Chain and as it is only being used by BiCycle, if we declare the Chain inside the BiCycle all the related configuration related to BiCycle will be there at one place and it would be easy to manage and understand the configuration at single shot.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Using IDRef</span></div>
<p>In some cases a bean wants to use the id of another bean, so how to inject "id" of a bean into another bean, here we need to use IDRef.<br><br> 
For example Car needs an Engine to run, to use Engine inside Car we can inject Engine into the Car, but I don’t want to inject rather we want to pull, to pull we need the id of the Engine inside the car. So, we are injecting the "id" of the engine into the Car as shown below.</p>
<p  style="font-weight:bold;color:#212121">Car.java</p>
  <pre ><code class="language-java">package com.idref.beans; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.idref.beans.Engine; public class Car { 
private String beanId; 
public void setBeanId(String beanId) {   
this.beanId = beanId;  
} 
public void run() {   
Engine engine = null;   
BeanFactory factory = new XmlBeanFactory(
new ClassPathResource(“com/idref/common/application-context.xml”));                    
engine = factory.getBean(beanId, Engine.class);   
engine.start();   
System.out.println(“Running….”);  
} 
}  </code></pre>
  <p  style="font-weight:bold;color:#212121">Engine.java</p>
  <pre ><code class="language-java">package com.idref.beans; 
public class Engine {  
public void start() {   
System.out.println(“Started…”);  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121"><p  style="font-weight:bold;color:#212121">application-context.xml </p>
  <pre ><code class="language-java">&ltbean id="car" class="com.idref.beans.Car">  
&ltproperty name="beanId" value=”engine”/> 
&lt/bean> 
&ltbean id="engine" class="com.idref.beans.Engine" /> </code></pre></p>
  <pre ><code class="language-java">package com.idref.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.idref.beans.Car; 
public class IDRefTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/idref/common/application-context.xml"));   
Car car= factory.getBean("car", Car.class);   
System.out.println(car);  
} 
}</code></pre>
<p>Will the above program work’s? Yes but there is a problem with the above piece of code. The problem here is we are passing the bean id "engine" as value into the Car, If the bean id has been changed let's say from "engine" to "engine1" then it would be difficult to track and change the as the property is configured as value.<br><br>
<ol>
<li>Developer will not be able to understand upon looking into configuration whether to modify or not as it looks like a simple value</li>
<li>Spring will try to create the IOC Container even the configuration is inconsistent, which will results in an runtime exception while getting the Engine using factory.getBean</li>
</ol> 
<p>To avoid the above problems it is recommended to pass the id of another bean as value using idref tag. "ref" means referring an object, "idref" means ref to an id of another bean. Below example that shows the same</p>
  <p  style="font-weight:bold;color:#212121">application-context.xm</p>
  <pre ><code class="language-java">&ltbean id="car" class="com.idref.beans.Car">  
&ltproperty name="beanId">              
&ltidref bean="engine"/>          
&lt/property> &lt/bean> 
 &ltbean id="engine" class="com.idref.beans.Engine" /> </code></pre>
 <p>With the above spring while creating the Car bean in the IOC container, it checks is any bean with id as "engine" exists if found then only creates the car and injects the value "engine" into the Car. Otherwise will stop creating the object and throws an exception</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Aliasing</span></div>
<p>In spring when you configure a class as Bean you will declare an id with which you want to retrieve it back from the container. Along with id you can attach multiple names to the beans, and these names acts as alias names with which you can look up the bean from the container.<br><br> 
Prior to spring 2.0 in order to declare multiple names you need to declare an “name” attribute at the bean tag level whose value contains bean names separated with ",".<br><br> 
Following code snippet shows the same</p>
  <pre ><code class="language-java">package com.ba.beans; 
public class Robot {  
private int id;  
private String name; 
// setters  
@Override  
public String toString() {   
return "Robot [id=" + id + ", name=" + name + "]";  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
  <pre ><code class="language-java">&ltbean id="robot" name="agent, machine" class="com.ba.beans.Robot">  
&ltproperty name="id" value="10"/>  
&ltproperty name="name" value="Robot-1"/> 
&lt/bean> </code></pre>
<p>You can retrieve the above bean with either robot or agent or machine names. You can even get all the names of the bean using factory.getAliases("onename").<br><br> 
In general bean aliasing is used for ease maintenance of the configuration.<br><br>  
In spring 2.0 a new tag has been introduced <alias> using which you can declare multiple names for the bean. The syntax is as follows</p>	
  <pre ><code class="language-java">&ltbean id="robot" class="com.ba.beans.Robot"/> 
&ltalias name="agent" alias="robot"/> 
&ltalias name="machine" alias="robot"/>  </code></pre>
  <pre ><code class="language-java">package com.ba.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.ba.beans.Robot; 
public class BATest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/ba/common/application-context.xml"));                    
// this will work as agent is alias name of robot bean   
Robot robot= factory.getBean("agent", Robot.class);   
System.out.println(robot); 
String[] aliases = factory.getAliases("robot");                   
for(String alias : aliases) {                      
System.out.println("alias : " + alias);                 
}  
} 
} </code></pre>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Null String</span></div>
<p>The concept of Null string is how to pass Null Value for a Bean property. Let's consider a case where a class has attribute as String or other Object. We are trying to inject the value of this attribute using Constructor Injection.<br><br> 
In case of constructor injection the dependent object is mandatory to be injected in configuration. In case if the dependent object is not available, you can pass null for the dependent object in the target class constructor as shown below.</p>
<p  style="font-weight:bold;color:#212121">Motor.java </p>
  <pre ><code class="language-java">package com.un.beans; 
public class Motor {  
private String id; 
public Motor(String id) {   
this.id = id;  
}  
// toString() 
} </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml</p>
  <pre ><code class="language-java"><bean id="m1" class="com.un.beans.Motor">  
<constructor-arg>   
<null/>  
</constructor-arg> 
</bean>  </code></pre>
<p>If you see the declaration, in order to pass null as value for the dependent object you need to use the tag &ltnull/&gt. </p>
  <pre ><code class="language-java">package com.un.test; 
import org.springframework.beans.factory.BeanFactory; 
import org.springframework.beans.factory.xml.XmlBeanFactory; 
import org.springframework.core.io.ClassPathResource; 
import com.un.beans.Motor; 
public class UNTest {  
public static void main(String[] args) {   
BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
"com/un/common/application-context.xml"));   
Motor motor= factory.getBean("motor", Motor.class);   
System.out.println(motor);  
} 
}</code></pre>
<p>With the above the Motor object will be created by initializing the String id to null.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Scopes</span></div>
<p>In spring when you declare a class as a bean by default the bean will be created under singleton scope. Before understanding about scopes we need to understand what singleton class is and when to use it. </p>
<p><b>What is singleton, when to use</b></p>
<p>When we create a class as singleton, it means we have only one instance of the class within the classloader.<br><br> 
We need to use singleton class in the below scenarios</p>
<ol>
<li>If a class has absolutely no state then declare those classes as singleton, as the class doesn't contains any attributes and it has only behavior's, calling the methods with object1 or object 2 doesn't makes any difference. So, instead of floating multiple objects in memory, we can have one object calling any methods of that class</li>
<li>If a class has some state, but the state is read-only in nature then all the objects of that class sees the same state, so using the class behavior's with one object or n objects doesn’t makes any difference, so we can use only one object of the class rather than multiple.</li>
<li>If a class has some state, but the state can be shared across multiple objects of the class. The state it contains is not only sharable but also it is very huge in nature, so instead of declaring multiple objects of that class we can allow to access the shared state through one object. But should allow the write/read access to the state via serialized order (synchronized fashion). For e.g.. all the cache classes has shared state which is shared across multiple objects of that class, but write/read operations to the cache data will be allowed in a synchronized manner.</li>
</ol>
<p>In all the above scenarios we need to declare the class as Singleton. If a class is inverse of the above principles we should not declare the class as singleton rather should create multiple instances to access it.</p>
<p>In spring you can declare a bean with 5 different scopes as follows.</p>
<ol>
<li>Singleton – by default every bean declared in the configuration file is defaulted to singleton (unless specified explicitly). This indicates when you try to refer the bean through injection or factory.getBean() the same bean instance will be returned from the core container. </li>
<li>Prototype – When we declare a bean scope as prototype this indicates every reference to the bean will return a unique instance of it.</li>
<li>Request – When we declare a bean scope as request, for every HTTPRequest a new bean instance will be injected </li>
<li>Session – For every new HttpSession, new bean instance will be injected.</li>
<li>Global Session – the globalsession scope has been removed from Spring 3.0. This is used in Spring MVC Portlet framework where if you want to inject a new bean for a Portal Session you need to use this scope.</li>
</ol>
<p>By the above it is clear that you can use request and session in case of web applications. So we will postpone the discussion on these till Spring MVC.<br><br> 
Let’s understand how to use singleton and prototype. </p>
<p  style="font-weight:bold;color:#212121">DateUtil.java</p>
  <pre ><code class="language-java">package com.bs.beans; 
import java.text.SimpleDateFormat; 
import java.util.Date; 
public class DateUtil {   
public String formatDate(Date dt, String pattern) {   
String s = null;     
SimpleDateFormat sdf = new SimpleDateFormat(pattern);   
s = sdf.format(dt);     
return s;  
} 
}  </code></pre>
<p  style="font-weight:bold;color:#212121">application-context.xml </p>
  <pre ><code class="language-java">&ltbean id="dateUtil" class="com.bs.beans.DateUtil" scope="prototype"/> </code></pre>
 <p  style="font-weight:bold;color:#212121">BeanScopeTest.java</p>
  <pre ><code class="language-java">package com.ba.test; 
 import org.springframework.beans.factory.BeanFactory; 
 import org.springframework.beans.factory.xml.XmlBeanFactory; 
 import org.springframework.core.io.ClassPathResource; 
 import com.bs.beans.DateUtil; 
 public class BSTest {  
 public static void main(String[] args) { 
 BeanFactory factory = new XmlBeanFactory(new ClassPathResource(     
 "com/bs/common/application-context.xml")); 
 DateUtil du1 = factory.getBean("dateUtil", DateUtil.class); 
 DateUtil du2 = factory.getBean("dateUtil", DateUtil.class); 
 System.out.println(du1 == du2);  
 } 
 } </code></pre>
<p>As in the configuration we declare the dateUtil bean scope as prototype the comparision between du1 == du2 will returns false. If we set the scope as singleton it will yields to true</p> 
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Bean Autowiring</span></div>
<p>In spring when you want to inject one bean into another bean, we need to declare the dependencies between the beans using ;ltproperty;gt or ;ltconstructor-arg;gt tag in the configuration file. This indicates we need to specify the dependencies between the beans and spring will reads the declarations and performs injection.<br><br> 
But when it comes to autowiring, instead of we declaring the dependencies we will instruct spring to automatically detect the dependencies and perform injection between them.<br><br>  
So, in order to do this we need to enable autowiring on the target bean into which the dependent has to be injected. You can enable autowiring in 4 modes.</p>
<ol>
<li>byname – If you enable autowiring by name, spring will finds the attribute name which has setter on the target bean, and finds the bean in configuration whose name is matching with the attribute name and performs the injection by calling the setter. Following code demonstrates the same.</li>
</ol>
<p  style="font-weight:bold;color:#212121">Humpty.java</p>
  <pre ><code class="language-java">package com.ba.beans; 
public class Humpty {  
private Dumpty dumpty;    
public void setDumpty(Dumpty dumpty) {   
System.out.println("Setter");   
this.dumpty = dumpty;  } 
public void showHumpty() {   
System.out.println("I am working with Dumpty : " + dumpty.getName());  
} 
}</code></pre>
  <p  style="font-weight:bold;color:#212121">Dumpty.java</p>
  <pre ><code class="language-java"> package com.ba.beans; 
public class Dumpty {  
private String name; 
public String getName() {   
return name;  
} 
public void setName(String name) {   
this.name = name;  
} 
} </code></pre>
  <p  style="font-weight:bold;color:#212121">application-context.xml </p>
  <pre ><code class="language-java">&ltbean id="humpty" class="com.ba.beans.Humpty" autowire="byName"/>   
&ltbean id="dumpty" class="com.ba.beans.Dumpty">  
&ltproperty name="name" value="Dumpty12"/> 
&lt/bean></code></pre>
<p>If you see the above configuration, on the humpty we enabled autowire byName. With this configuration, it will tries to find the Humpty beans attributes which has setters, with that attribute name "dumpty" it will tries to find a relevant bean with the same name "dumpty" as the bean is available it will injects the dumpty bean into Humty attribute. </p>
<p>2).byType - If we enable autowire byType, if will find the attributes type in the target class and tries to identify a bean from the configuration file of the same type and then injects into target class by calling setter on top of it. Below configuration demonstrates the same</p>
<p  style="font-weight:bold;color:#212121">application-context.xml </p>
<pre ><code class="language-java"> &ltbean id="humpty" class="com.ba.beans.Humpty" autowire="constructor"/>   
&ltbean id="dumpty12" class="com.ba.beans.Dumpty">  
&ltproperty name="name" value="Dumpty12"/> 
&lt/bean></code></pre>
<p>In the above case the bean attribute name is "dumpty", and in the configuration the bean name is "dumpty12" even though the names are not matching still the dumpty12 bean will be injected into humpty. Because the type of the attribute and the bean type is matching. </p>
<p>Note:- if multiple bean declarations of the same type is found it will throw an ambiguity error without instantiating the core container.</p>
<ol>
<li>Constructor - If we enable autowire in constructor mode, now it will tries to find a bean whose class type is same as constructor parameter type, if a matching constructor is found it will passes the bean reference to its constructor and performs injection. This means it is similar to byType but instead of calling setter it will call constructor to perform injection.</li>
</ol>
<p  style="font-weight:bold;color:#212121">Humpty.java</p>
  <pre ><code class="language-java">package com.ba.beans; 
public class Humpty {  
private Dumpty dumpty;    
public Humpty() {   
super();  
}  
public Humpty(Dumpty dumpty) {   
System.out.println("Constructor");   
this.dumpty = dumpty;  
} 
public void showHumpty() {   
System.out.println("I am working with Dumpty : " + dumpty.getName());  
} 
}  </code></pre>
<p>There is no change in configuration apart from declaring on the bean autowire="constructor"</p>
<ol>
<li>Autodetect - this has been removed from spring 3.0 onwards as it is quite confusing. In this it will tries to perform injection by finding a relevant constructor by type if not found then it will finds the setter by type and performs injection.</li>
</ol>
<p>Drawback with autowiring - The problem with autowiring is we don't have control over which beans has to get injected into what, so it is least recommended to use autowiring for a large applications. For pilot projects where RAPID application development is needed we use autowiring.</p>
<div style="text-align: left; background:#696969; padding:7px;"><span style="font-weight:bold;color:#ffffff">Nested BeanFactories</span></div>
<p>If we have two bean factories in an application, we can nest one bean factory into another to allow the beans in one bean factory to refer to the beans of other factory. In this we declare one bean factory as parent bean factory and will declare the other as child.<br><br> 
This is similar to the concept of base class and derived classes. Derived class can access the attributes of base class, but base class cannot access the attributes of derived class.<br><br> 
In the same way child bean factory beans can refer to the parent bean factory beans. But parent bean factory beans cannot refer to child beans declared in child factory. Pictorial representation of it is shown below.</p>
<img src="../images/two13.jpg" width="100%" height="200px">
<p>Below example shows how to use it. </p>
<p  style="font-weight:bold;color:#212121">EMICalculator.java</p>
  <pre ><code class="language-java">package com.nbf.beans; 
public class EMICalculator {  
public float compute(long principal, float rateOfInterest, int years) {   
return 343.34f;  
} 
} </code></pre>
<p  style="font-weight:bold;color:#212121">CustomerLoanApprover.java</p>
  <pre ><code class="language-java">package com.nbf.beans; 
public class CustomerLoanApprover {  
private EMICalculator emiCalculator; 
public void approve(double grossSalary, long principalAmount, int years) {   
float emi = emiCalculator.compute(principalAmount, 13.5f, years);   
System.out.println("Emi : " + emi);   
if (emi > 0) {    
System.out.println("Approved");   
} 
else {    
System.out.println("Rejected");   
}  
} 
public void setEmiCalculator(EMICalculator emiCalculator) {   
this.emiCalculator = emiCalculator;  
} 
}  </code></pre>
<p>If the EMICalculator class has been declared in one configuration file and CustomerLoanApprover class has been declared in second configuration file. In order to inject EMICalculator into CustomerLoanApprover class we need to nest their factories as shown below</p>
<p  style="font-weight:bold;color:#212121">loan-beans.xml </p>
  <pre ><code class="language-java">&ltbean id="emiCalculator" class="com.nbf.beans.EMICalculator"/> </code></pre>
  <p  style="font-weight:bold;color:#212121">customer-beans.xml </p>
<pre ><code class="language-java">&ltbean id="customerLoanApprover" class="com.nbf.beans.CustomerLoanApprover">  
&ltproperty name="emiCalculator">   
&ltref parent="emiCalculator"/>  
&lt/property> 
&lt/bean> </code></pre>
<p>In the above configuration in order for your bean declaration to refer to parent beans, it has to use the tag &ltref parent = ""/&gt. Apart from parent attribute it has local which indicates refer to the local bean. Along with it we have bean attribute as well, which indicates look in local if not found the search in parent factory and perform injection</p>
<p  style="font-weight:bold;color:#212121">NBFTest.java</p>
  <pre ><code class="language-java">public static void main(String[] args) {  
BeanFactory pf = new XmlBeanFactory(new ClassPathResource(    
"com/nbf/common/loan-beans.xml"));  
BeanFactory cf = new XmlBeanFactory(new ClassPathResource(    
"com/nbf/common/customer-beans.xml"), pf); 
CustomerLoanApprover cla = cf.getBean("customerLoanApprover",    
CustomerLoanApprover.class);  
cla.approve(3423.3f, 3535, 324); 
} </code></pre>
<p>If you observe the above code while creating the "cf" factory we passed the reference of "pf" to create it. This indicates "cf" factory has been nested from "pf".<br><br> 
 This completes the Spring Core basic concepts and enables us to proceed for advanced spring core concepts. </p>











  

	  





















	
		
</div>
</div>
<script>var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var r=n.util.type(e);switch(t=t||{},r){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a={};t[n.util.objId(e)]=a;for(var l in e)e.hasOwnProperty(l)&&(a[l]=n.util.clone(e[l],t));return a;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a=[];return t[n.util.objId(e)]=a,e.forEach(function(e,r){a[r]=n.util.clone(e,t)}),a}return e}},languages:{extend:function(e,t){var r=n.util.clone(n.languages[e]);for(var a in t)r[a]=t[a];return r},insertBefore:function(e,t,r,a){a=a||n.languages;var l=a[e];if(2==arguments.length){r=arguments[1];for(var i in r)r.hasOwnProperty(i)&&(l[i]=r[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in r)r.hasOwnProperty(i)&&(o[i]=r[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===a[e]&&t!=e&&(this[t]=o)}),a[e]=o},DFS:function(e,t,r,a){a=a||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],r||l),"Object"!==n.util.type(e[l])||a[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||a[n.util.objId(e[l])]||(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,a)):(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,a)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,r){var a={callback:r,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var l,i=a.elements||e.querySelectorAll(a.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,a.callback)},highlightElement:function(t,r,a){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),r&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,a){var l={code:e,grammar:t,language:a};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),r.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,r,a,l,i,o){var s=n.Token;for(var u in r)if(r.hasOwnProperty(u)&&r[u]){if(u==o)return;var g=r[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=a,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join("");var l={type:e.type,content:r.stringify(e.content,t,a),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:a};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.java=Prism.languages.extend("clike",{keyword:/\b(?:abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,number:/\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp-]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?[df]?/i,operator:{pattern:/(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,lookbehind:!0}}),Prism.languages.insertBefore("java","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}}),Prism.languages.insertBefore("java","class-name",{generics:{pattern:/<\s*\w+(?:\.\w+)?(?:\s*,\s*\w+(?:\.\w+)?)*>/i,alias:"function",inside:{keyword:Prism.languages.java.keyword,punctuation:/[<>(),.:]/}}});
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var e="line-numbers",t=/\n(?!$)/g,n=function(e){var n=r(e),s=n["white-space"];if("pre-wrap"===s||"pre-line"===s){var l=e.querySelector("code"),i=e.querySelector(".line-numbers-rows"),a=e.querySelector(".line-numbers-sizer"),o=l.textContent.split(t);a||(a=document.createElement("span"),a.className="line-numbers-sizer",l.appendChild(a)),a.style.display="block",o.forEach(function(e,t){a.textContent=e||"\n";var n=a.getBoundingClientRect().height;i.children[t].style.height=n+"px"}),a.textContent="",a.style.display="none"}},r=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener("resize",function(){Array.prototype.forEach.call(document.querySelectorAll("pre."+e),n)}),Prism.hooks.add("complete",function(e){if(e.code){var r=e.element.parentNode,s=/\s*\bline-numbers\b\s*/;if(r&&/pre/i.test(r.nodeName)&&(s.test(r.className)||s.test(e.element.className))&&!e.element.querySelector(".line-numbers-rows")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s," ")),s.test(r.className)||(r.className+=" line-numbers");var l,i=e.code.match(t),a=i?i.length+1:1,o=new Array(a+1);o=o.join("<span></span>"),l=document.createElement("span"),l.setAttribute("aria-hidden","true"),l.className="line-numbers-rows",l.innerHTML=o,r.hasAttribute("data-start")&&(r.style.counterReset="linenumber "+(parseInt(r.getAttribute("data-start"),10)-1)),e.element.appendChild(l),n(r),Prism.hooks.run("line-numbers",e)}}}),Prism.hooks.add("line-numbers",function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0}),Prism.plugins.lineNumbers={getLine:function(t,n){if("PRE"===t.tagName&&t.classList.contains(e)){var r=t.querySelector(".line-numbers-rows"),s=parseInt(t.getAttribute("data-start"),10)||1,l=s+(r.children.length-1);s>n&&(n=s),n>l&&(n=l);var i=n-s;return r.children[i]}}}}}();
!function(){"undefined"!=typeof self&&!self.Prism||"undefined"!=typeof global&&!global.Prism||Prism.hooks.add("wrap",function(e){"keyword"===e.type&&e.classes.push("keyword-"+e.content)})}();
</script>
</body>
</html> 
